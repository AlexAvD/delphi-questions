## Вопросы

1. [Динамическая память и указатели.](#1)
2. [Модули](#2)
3. [Основы визуального программирования. Интегрированная среда разработки Delphi.](#3)
4. [Классы. Инкапсуляция. Наследование. Полиморфизм. Поля. Методы. (Статические, динамические, конструктор и деструктор).](#4)
5. [Объявление класса. Свойства. События. Область видимости элементов класса.](#5)
6. [Компоненты. Класс TObject. Класс TPersistent. Класс TComponent.](№6)
7. [Класс TControl.](#7)
8. [Класс TWinControl. Класс TGraphicControl.](#8)
9. [Компоненты Label, Button BitBtn, SpeedButton.](#9)
10. [Класс TCustomEdit. Edit.](#10)
11. [Текстовый редактор Memo. Класс TStrings.](#11)
12. [Классы и компоненты, предназначенные для создания изображения. Класс TFont. Класс TPen. Класс TBrush. Класс TCanvas.](#12)
13. [Компонент Image. Компонент Shape.](#13)
14. [Компонент Timer.](#14)
15. [Панель переключателей RadioGroup и список выключателей CheckListBox.](#15)
16. [Панель (зависимых переключателей RAdioGroup).](#16)
17. [Список независимых выключателей CheckListBox.](#17)
18. [Список ListBox. Комбинированная строка ввода ComboBox.](#18)
19. [Создание меню. Главное меню. Контекстное меню PopupMenu.](#19)
20. [Класс TStringGrid.](#20)
21. [Диалоговые окна.](#21)
22. [Форма. Характеристики формы. Создание формы. Активность формы. События формы. Управление видимостью. Получение фокуса. Перерисовка формы. Закрытие формы. Обработка событий клавиатуры. Оформление формы. Слить формы.](#22)
23. [Рамка. Кнопки. Размещение и размер. Полосы прокрутки. Взаимодействие форм.](#23)
24. [Модальные формы. Диалоговые окна. Стандартные диалоговые окна. Шаблоны форм.](#24)
25. [Приложение.](#25)
26. [Работа с файловой системой. Диск. SysUtils. Каталоги. SysUtils. Файлы. DriveComboBox. DirectoryListBox. FileListBox. FilterComboBox.](#26)
27. [Обработка исключений. Классы исключений. Наиболее часто используемые исключения.](#27)
28. [Обработка исключений. Глобальная обработка. Локальная обработка. Вызов исключений.](#28)
29. [Технологиия программирования и основные этапы ее развития.](#29)
30. [Проблемы разработки сложных программных систем.](#30)
31. [Блочно-иерархический подход к созданию сложных систем.](#31)
32. [Жизненный цикл и этапы разработки программного обеспечения.](32)
33. [Эволюци моделей жизненого цикла программного обеспечения.](#33)
34. [Ускорение разработки программного обеспечения. Технология RAD.](#34)
35. [Тестирование и отладка.](#35)

*** 

## <a name="1"></a> 1. Динамическая память и указатели.

Динамические переменные - это переменные, память под которые выделяется во время выполнения 
программы.
Основным механизмом для организации динамических данных является выделение в специальной области памяти, называемой « heap-областью» или «кучей», непрерывного участка подходящего размера и сохранения адреса начала этого участка в специальной переменной,  называемой, ссылочной переменной  или ссылкой или указателем.
Ссылочная переменная (указатель) – переменная, предназначенная для хранения адреса переменной, расположенной в динамической области памяти (heap – области или «куче»).
Сам указатель располагается в статической памяти.

    Type 
        DinMas=array[1..10000] of real;
        p1=^integer; 
        p2=^real; 
        P3=^DinMas;
    Var 
        A,B,C:p1; 
        X,Y,Z:p2; 
        M:p3;
        P:^char;
        T:^integer;

***

## <a name="2"></a> 2. Модули.

Модуль - это автономно компилируемая программная единица, содержащая константы, типы, переменные, процедуры функции.
Работа с модулем состоит из двух частей: написание и компиляция;
Достоинства модулей: модули избавляют от необходимости работать с второстепенным кодом, а сосредоточится на главном.
Недостатки: позднее обнаружения ошибок на этапе выполнения.

    Unit <name>;
    Uses <list of modules>; // Используемый модуль
    interface <constants, variables, types, имена процедуры функции которые будут видные пользователю >;
    implementation <local variables, constants, types, процедуры функции и реализация интерфейсных процедур и функций>;
    initialization <операторы которые претворяют запуск модуля>;
    finalization <операторы предшествующие окончанию работы модуля>;
    end.


***

## <a name="3"></a> 3. Основы визуального программирования. Интегрированная среда разработки Delphi.

***

## <a name="4"></a> 4. Классы. Инкапсуляция. Наследование. Полиморфизм. Поля. Методы. (Статические, динамические, конструктор и деструктор).

### Классы.

**Классы** – это типы специального вида, которые содержат поля, методы и свойства. 
Классы, как и любые другие типы, служат образцами для создания  конкретных экземпляров. 
Конкретные  экземпляры класса называются объектами. 


Объявление класса:

    Type 
        TmyCl=class(Tobject)
            Fint:integer;
            Fstr:string;
            Function Func1(a:real):integer;		
            Procedure Proc1;
        End;
    Var 
        MyClass:TmyCl;  
    Function TmyCl.Func1(a:real):integer;
            Begin result:=a* Fint ; end;
    Procedure TmyCl.Proc1;
            Begin …; end;
    Begin 
        MyClass:=TmyCl.create;
        MyClass.Fint:=10;
        MyClass. Proc1;
        MyClass.Free;
    End.

### Инкапсуляция.

**Инкапсуляция** – это объединение в одно целое трех сущностей: полей, методов и свойств.

Поля уникальные, методы общие. Инкапсуляция предполагает, что поля, методы и свойства в классе функционально самодостаточны для решение какой либо задачи. Инкапсуляция предполагает разграничение уровня доступа разработчиков разного уровня, потому-что: 

* пользователи класса не должны видеть подробности которыми оперирует разработчик; 
* прямой доступ к поля хотя и возможен, но нежелателен;

Инкапсуляция позволяет изолировать класс от остальных частей программы, сделать его самодостаточным для решения конкретной задачи. 
Инкапсуляция предполагает разграничение доступа разработчиков разного уровня к различным членам класса.

### Наследование.

Любой класс может быть порожден от другого класса. Порожденный 
класс автоматически наследует все члены родителя, но может и пополнять их.

### Полиморфизм.

**Полиморфизм** – это возможность в классах потомках переопределять (перекрывать) методы родителей.

### Поля.

**Поля** – это данные.

### Методы.

**Методы** – это процедуры, обрабатывающие данные.
Инкапсулированные в классе процедуры и функции называются методами.
В ООП различаются следующие виды методов:

* Методы класса 
* Конструктор и деструктор 
* Виртуальные
* Динамические
* Абстрактные 
* Перегружаемые

### Конструктор и деструктор.

В состав любого класса входят два специальных метода – конструктор и деструктор. 
В классе TОbject конструктор называется create деструктор destroy. 
Конструктор и деструктор – это функция и процедура, но в виду важности они объявляются с помощью зарезервированных слов Constructor Destructor.

    Type
        TmyCl=class(TObject)
	        …
        end;
    Var
        Ob1: TmyCl; //выделяет указатель 4 б, cначалa хранит nil
    Для разворачивания же объекта в динамической памяти используется метод класса конструктор (для Tobject это Create) в таком виде:
    Ob1:= TmyCl.Create;


***

## <a name="5"></a> 5. Объявление класса. Свойства. События. Область видимости элементов класса.

### Объявление класса.

    Type 
        TmyCl=class(Tobject)
            Fint:integer;
            Fstr:string;
            Function Func1(a:real):integer;		
            Procedure Proc1;
        End;

### Свойства.

**Свойства** – это механизм доступа к данным.

    Type
        TMan=class(Tobject)
            private
                FVozrast:integer;
            protected
                Function GetVozr:integer;
                Procedure SetVozr(r:integer); 
            public 
                Property Vozrast:integer read GetVozr write SetVozr; // свойство
        End;

    Var 
        мan: TМan;
    Function TМan.GetVozr:integer;
        Begin result:= FVozrast; end;
    Procedure TМan.SetVozr(r:integer); 
        Begin 
            if r<100 then FVozrast:=r else exit;
        end;

### События.

Событие – это то, что происходит в результате работы компьютера. На низком уровне это изменения, (нажатие кнопки, исход времени, деление на ноль) вызывающие прерывания.
С точки зрения языка событие - это свойство процедурного типа, его значением является указатель на некоторый метод. 

    Type 
        TControl = class (TComponent) 
            Private
                FOnDblClick: TNottifyEvent ;
                ……………………..
            Protected
                property OnDblClick: TNottifyEvent  read  FOnDblClick  write  FOnDblClick;
                ………………………
                end; 
        TNotifyEvent = Procedure(Sender:TObject) of object;

### Область видимости элементов класса.

В Delphi есть четыре модификатора разграничения доступа:

* **public**
* **published**
* **potected**
* **private**

Модификатором **public** объявляют (помечают ) члены класса видимые везде. 
А именно, в любой программе и в любом модуле, которые имеют доступ к нашему модулю, (т.е. где наш модуль объявлен в разделе USES).
Модификатором **published** объявляют члены класса видимые везде, но более того, свойства помещенные в эту секцию видимы еще и в инспекторе объектов. 
Секция, не имеющая модификатора доступа, по умолчанию считается published
Модификатором **protected** объявляют члены класса доступные методам самого класса и их потомкам.
Модификатором **private** объявляют члены класса видимые только в модуле, где описан класс, т.е. это локальные описания.

***

## <a name="6"></a> 6. Компоненты. Класс TObject. Класс TPersistent. Класс TComponent.

### Класс TObject.


Предок всех классов. Класс абстрактный. Обеспечивает возможность создания и разрушения объектов. 	
Для этого определены следующие методы.
Constructor Create – выделяет динам память, инициализацию не делает, т.к. перегружается.
Destructor Destroy; virtual; - освобождает выделенную память.
Procedure Free – проверяет существование и, если память выделялась, то освобождает ее.
Методы класса:

* ClassName: shortString; - возвращает имя класса данного объекта
* ClassNameIs (const Name:string):Boolean; - данный класс совпадает Name
* InheritsForm(aClass:Tclass):Boolean; - является ли класс предком дан кл
* InstanceSize:Longint; - возвращает размер класс или объекта.


### Класс TPersistent.

Его объекты инкапсулируют в себе некоторый носитель информации. Память или дисковые файлы. 
Методы класса:

* Procedure Assign(Source:Tpersistent); - присваивает данному объекту данные, содержащиеся в объекте с именем Source
* Function GetNamePath: string; dynamic; - возвращает строку, содержащую имя объекта.
* Function GetOwner: TPersistent; dynamic;- возвращает указатель на владельца объекта.


### Класс TComponent.

Вершина иерархии компонентов. Потомки его - невизуальные компоненты    (TApplication, Tform таймер, меню, диалоговые окна). 

Свойства класса:

* Name  (строка ) – имя компонента. При помещении компонента на форму присваивается стандартное имя Label1, Edit1, которое можно заменить на более осмысленное, при этом имя должно быть правильным идентификатором.
* Tag: Longint; - некоторое число, которым разработчик может распоряжаться по усмотрению.

В классе TComponent вводится концепция принадлежности, которая распространяется на всю VCL. Суть: 
любой компонент Делфи является собственностью другого компонента. 
при разрушении компонента владельца автоматически разрушается принадлежащие ему компоненты. 
Свойства реализующие концепцию принадлежности:

* ComponentCount:Integer; - количество компонентов во владении
* ComponentIndex:Integer; - номер компонента в списке владельца (нумерация с нуля).
* Components \[Index:Integer\]:TComponent; - список компонен-тов, для которых данный является владельцем.
* Owner: TComponent; - содержит указатель на компонент владелец для текущего компонента. 

Методы класса:

* Constructor Create (AOwner: TComponent);virtual;  - создает объект данного класса, помещает ссылку на себя в массив Components, своего владельца, имя которого указано в AOwner.
* Destroy Tcomponent;- удаляет из памяти компоненты данного владельца.
* Procedure InsertComponent(Acomponent: TComponent); - вставляет новый компонент с именем Acomponent.
* Procedure RemoveComponent(Acomponent: TComponent); - удаляет компонент Acomponent. 

***

## <a name="7"></a> 7. Класс TControl.


Потомки этого класса называются элементами управления.
Это визуальные компоненты  с их помощью информация выводится на экран.
В потомках TControl вводится понятие родительского элемента управления суть его в следующем:
Каждый элемент управления может быть помещен в груп-пирующий элемент. Дочерние не могут выходить за рамки роди-тельского, при перемещении родительского перемещаются и дочерние.
Дочерний элемент использует некоторые родительские свойства (цвет, шрифт). Визуально изображение родительского и дочернего на экране получает единый хороший стиль.
В качестве родительского может выступать только оконный элемент управления, т.е. потомок TWinControl, дочерние элементы управления могут быть любыми.
Не следует путать владельца и родителя

***

## <a name="8"></a> 8. Класс TWinControl. Класс TGraphicControl.

### Класс TWinControl.

Потомок TControl – является базовым для создания оконных элементов управления. 
Такие элементы во время выполнения программы могут получать фокус ввода,  реагируют на события, возникающие при использовании клавиатуры. Наличие окна позволяет активизировать элемент управления во время выполнения программы. 
С каждым оконным элементом управления связано окно Windows, определяемое специальным числовым идентификатором – дескриптором окна.
В этом классе  завершается определение характеристик связи родительский дочерний, начатое в TControl  (только оконный элемент может быть контейнером для содержания других компонентов).

### Класс TGraphicControl.

Потомки этого класса имеют общее название – графические элементы управления. 
Потомки TGraphicControl: фокус ввода не получают, не могут быть родительскими для других, 
реагируют на события мыши. 
Их назначение – вывод информации на экран, улучшение внешнего вида.Представители: Label, Shape- фигура, PaintBox – паненль рисования, Imege.
	
Property Canvas: TCanvas; - (канва - холст) средства предназ-наченные для создания на экране графического изображения. 

Procedure Paint; - рисует изображение графического элемента управления. В потомках обычно переопределяется, чтобы учесть специфику.

***

## <a name="9"></a> 9. Компоненты Label, Button BitBtn, SpeedButton.

### Label.

Компонент Label предназначен для отображения статического текста, то есть надписей и меток на Форме, которые не меняются в течение всего времени работы программы.

### Button BitBtn.

BitBtn это пиктографическая кнопка, представляющая собой один из вариантов стандартной кнопки Button. В отличие от последней кнопка Delphi BitBtn умеет отображать на своей поверхности не только надпись, но и изображение, которое задаётся свойством Glyph.

### SpeedButton.

Компонент Delphi SpeedButton это ещё одна кнопка, имеющая свои отличия как от стандартной кнопки Button, так и от кнопки BitBtn.

* Первое отличие: в кнопках Delphi SpeedButton отсутствует свойство Kind;
* Второе отличие: кнопки Delphi SpeedButton имеют возможность быть зафиксированными в утопленном состоянии;
* Третье отличие: кнопки Delphi SpeedButton не имеют свойства ModalResult и, соответственно, не имеют возможности закрывать модальные окна.


***

## <a name="10"></a> 10. Класс TCustomEdit. Edit.

###  Класс TCustomEdit.

Компонент TCustomEdit не найти в палитре компонентов. В то же время он является общим предком для трех доступных вам редактирующих элементов - строки ввода TEdit, многострочного редактора TMemo и ввода данных по шаблону TMaskEdit. Поэтому здесь рассмотрим только его свойства, общие для всех трех.

В отличие от других визуальных компонентов, у перечисленных в этой группе текст содержится не в свойстве Caption, а в свойстве Text:

    property Text: TCaption;
    TCaption = string[255];

Часть текста может быть выделена. Свойства:

    property SelStart: Integer;
    property SelLength: Integer;

определяют начало и длину выделенного в редакторе текста (измеряемые в количестве символов). Сам выделенный текст содержится в строке, определяемой свойством:

    property SelText: string;

Метод:

    procedure ClearSelection;

исключает из текста весь выделенный фрагмент, а метод

    procedure SelectAll;

выделяет весь текст в редакторе. Доступны также рабочие методы по чтению/записи выделенного текста, которые используются свойством SelText:

    function GetSelTextBuf(Buffer: PChar; BufSize: Integer): Integer;
    procedure SetSelTextBuf(Buffer: PChar);

Они могут быть полезны для получения текста типа pChar, который применяется в функциях API Windows.

Текст можно передавать и принимать из буфера обмена Windows ? для этого предназначены три следующих метода. Если в окне редактора выделен текст, то передается (заменяется) именно он. В противном случае в операции участвует весь текст:

    procedure CopyToClipboard;
    procedure CutToClipboard;
    procedure PasteFromClipboard;

Очистить весь текст в редакторе можно при помощи метода:

    procedure Clear;

Наконец, свойство

    property Modified: Boolean;

устанавливает, изменялся ли текст в процессе редактирования.

### Edit

Компонент Delphi Edit представляет собой однострочное текстовое поле, служащее для ввода данных пользователем. Основным свойством компонента Delphi Edit, передающим введённую информацию, является свойство Edit1.Text типа String.

***

## <a name="11"></a> 11. Текстовый редактор Memo. Класс TStrings.

### Текстовый редактор Memo.

Компонент Delphi Memo это простой текстовый редактор. Delphi Memo позволяет вводить многострочный текст с клавиатуры, загружать его из файла, редактировать и сохранять в файл текстового формата.

Свойства memo:

* Name - Имя компонента. Используется в программе для доступа к свойствам компонента
* Text - Текст, находящийся в поле Memo. Рассматривается как единое целое
* Lines - Текст, находящийся в поле Memo. Рассматривается как совокупность строк. Доступ к строке осуществляется по номеру
* Lines.Count - Количество строк текста в поле Memo
* Left - Расстояние от левой границы поля до левой границы формы
* Top - Расстояние от верхней границы поля до верхней границы формы
* Height - Высоту поля
* Width - Ширину поля
* Font - Шрифт, используемый для отображения вводимого текста
* ParentFont - Признак наследования свойств шрифта родительской формы

### Класс TStrings.

Класс TStrings является базовым классом для операций со строковыми данными. Этот класс представляет собой контейнер для строк (коллекцию или массив строк). Для операций со строками класс TStrings предоставляет соответствующие свойства и методы. От класса TStrings происходит большое количество производных классов, например, TStringList, которые могут использоваться для задания различных типов строк.

Свойства TStrings:

* count — это свойство, которое вы можете только читать. Здесь хранится коли­чество строк, содержащихся в объекте.
* strings — здесь хранится набор строк. К любой строке можно получить доступ, написав такую конструкцию:

Методы объекта TStrings: 

* Add (Строка) — метод добавляет строку, указанную в качестве параметра в конец набора строк объекта. Возвращает номер, под которым добавлена новая строка.
Append (Строка) —этот метод тоже добавляет строку, указанную в качестве па-раметра, в конец набора строк объекта. Он ничего не возвращает.
AddStrings (Набор строк типа TStrings) — метод добавляет все Строки ИЗ другого объекта типа TStrings.
* Assign— метод присваивает вместо своего набора строк новый, указанный в качестве параметра.
* clear — метод удаляет все строки из объекта.
* Delete (Номер строки) — позволяет удалить строку под указанным номером.
* Equals (Набор строк типа TStrings) — метод допускает сравнение собственного набора строк с указанным в качестве параметра. Если наборы равны, то метод вернет true, иначе false.
Exchange (Номер1, номер2) — метод меняет местами строки указанных номеров.
* Get (номер строки) — метод возвращает строку указанного номера.
* indexof (Строка) —этот метод позволяет найти указанную в качестве параметра строку. Если такая строка существует в наборе, то метод вернет ее индекс, иначе— 1.
* insert (Номер, Строка) — метод позволяет вставить в набор новую строку под указанным номером.
* LoadFromFile (Имя файла) — данный метод используется, чтобы загрузить набор строк из указанного текстового файла.
* saveToFile(Имя файла) — метод обеспечивает сохранение набора строк в ука-занном текстовом файле.
* Move (номер 1, номер2) — метод перемещает строку под номером номер1 на место строки Номер2.

***

## <a name="12"></a> 12. Классы и компоненты, предназначенные для создания изображения. Класс TFont. Класс TPen. Класс TBrush. Класс TCanvas.

### Классы и компоненты, предназначенные для создания изображения.

В Delphi имеется несколько классов общего назначения, позволяющих выводить гра­фические изображения на поверхность компонентов. К ним относятся классы: TFont (шрифт), ТРеn (карандаш), TBrush (кисть) и TCanvas (канва). В составе многих компо­нентов Delphi имеются свойства Font, Pen, Brush и Canvas соответствующего типа, при помощи которых создаются изображения любых рисунков и текстов. Предком классов TFont, TPen и TBrush является класс TGraphicsObject, происходящий непосредственно от класса TPersistent. Предком класса TCanvas является класс TPersistent.

В классе TGraphicsObject отметим событие (свойство) OnChange:

    property OnChange: TNotifyEvent;

событие возникает при изменении графического объекта. После возникновения со­бытия графические объекты отображаются с обновленными значениями своих свойств.

В Delphi имеются компоненты, специально предназначенные для создания графичес­ких изображений:

* Image - представляет собой удобное средство для отображения готовых гра­фических файлов.
* Shape - используется для создания на форме простых геометрических фигур – квадратов, кругов, эллипсов и т. п.
* PaintBox - позволяет на этапе выполнения программы создавать несложные ри­сунки на своей Canvas; даёт нам простое окно с канвой для рисования произвольных изображений. Canvas (холст) содержится в свойстве Canvas компонента, графические инструменты в свойствах Font, Pen и Brush,
собственно рисование осуществляется в обработчике события OnPaint.

### Класс TFont.

Класс TFont задает характеристики шрифта, которым отображает-
ся текст в графической компоненте. Шрифт, который используется для
вывода текста, определяется значением свойства Font соответствую-
щего объекта Canvas. Для вывода текста на поверхность графического
объекта используются методы TextOut() и TextRect(), допускаю-
щие только горизонтальное расположение строк.

Свойства класса TFont:

* Property Charset: TFontCharSet; – набор символов. Для русскоязычных программ это свойство обычно имеет значение DEFAULTCHARSET или RUSSIAN CHARSET. Используйте значение OEMCHARSET для отображения текста MS–DOS (альтернативная кодировка);
* Property Color: TColor; – цвет шрифта;
* Property FontAdapter: IChangeNotifier; – указатель на интерфейс для передачи информации о шрифте в компоненты ActveX;
* Property Handle: hFont; – дескриптор шрифта. Используется при непосредственном обращении к API–функциям Windows;
* Property Height: Integer; – высота шрифта в пикселях;
* Property Name: TFontName; – имя шрифта. По умолчанию имеет значение MS Sans Serif;
* Property Pitch: TFontPitch; – определяет способ расположения букв в тексте: значение fpFixed задает моноширинный текст, при котором каждая буква имеет одинаковую ширину; значение fpVariabel определяет пропорциональный текст, при котором ширина буквы зависит от ее начертания; fpDefault определяет ширину, принятую для текущего шрифта;
* Property PixelPerInch: Integer; – определяет количество пикселей экрана на один дюйм реальной длины. Это свойство не следует изменять, так как оно используется системой для обеспечения соответствия экранного шрифта шрифту принтера;
* Property Size: Integer; – высота шрифта в пунктах (1/72 дюйма). Изменение этого свойства автоматически изменяет свойство Height и наоборот;
* Property Style: TFontStyles; – стиль шрифта. Может принимать значение как комбинацию следующих признаков: fsBold (жирный), fsItalic (кypсив), fsUnderline (подчеркнутый), fsStrikeOut (перечеркнутый).

### Класс TPen.

Класс TPen определяет объект «перо» для рисования линий.

Его основные свойства:

* Property Color:TColor; – цвет вычерчиваемых пером линий;
* Property Handle: Integer; – дескриптор пера. Используется при непосредственном обращении к API–функциям Windows;
* Property Mode:TPenMode ; – определяет способ взаимодействия линий с фоном (см. ниже);
* Property Style:TPenStyle; – определяет стиль линий. Этот стиль имеет слысл только для толщины линий в 1 пиксель. Для толстых линий стиль всегда psSolid (сплошная);

### Класс TBrush.

Класс TBrush служит для описания параметров кисти для заполнения внутреннего пространства замкнутых фигур.

Property Bitmap: TBitmap; – содержит растровое изображение, которое будет использоваться кистью для заполнения. Если это свойство определено, свойства Color и Style игнорируются;

* Property Color: TColor; – цвет кисти;
* Property Handle: Integer; – дескриптор кисти. Он используется при непосредственном обращении к API–функциям Windows;
* Property Style:TBrushStyle; – стиль кисти.

### Класс TCanvas.

Класс TCanvas представляет собой сложное образование для создания изображений. Он объединяет в себе устройство графического
интерфейса CDI, инструменты (перо, кисть и шрифт, которые уже рассмотрены) и набор методов для рисования простейших геометрических фигур. Класс TCanvas не является компонентом, а входит в качестве свойства во многие визуальные компоненты: TBitmap, TComboBox, TDBComboBox, TDBGrid, TDBListBox, TDirectoryListBox, TDrawGrid, TFileListBox, TForm, Tlmage, TListBox, TOutline, TPaintBox, TPrinter, TStringGrid. На канве можно представить наличие невидимого курсора, который определяет текущее положение карандаша. Для ряда случаев рисование тех или иных примитивов (например, линии) начинается с текущего положения этого курсора. Имеются средства установки курсора, в заданное положение. При выполнении некоторых операций
курсор меняет свое положение.

***

## <a name="13"></a> 13. Компонент Image. Компонент Shape.

###  Компонент Image.

Компонент delphi Image предназначен для отображение на форме графических изображений по умолчанию выводит на поверхность формы изображения представленных в bmp формате. Для вывода изображений в jpg формате необходимо в дерективе uses подключить модуль JPEG. После размещения  на форме компонента Image, он принимает вид выделенной прямоугольной области

Свойства Image:

* Picture - изображение отображающееся в поле компонента
* Width, Height - размеры компонента. Если эти размеры меньше размера иллюстрации, а значение свойств Strech, AutoSize и Proportional равны False, то отображается часть изображения
* Proportional - позволяет автоматически масштабировать картинки без искажения. Для выполнения масштабирования, значение свойства AutoSize должно быть равным False
* Strech - позволяет автоматически масштабировать (сжимать или растягивать) изображение в  соответствии с размером компонента Image. Если размер компонента не пропорционален размеру изображения, то изображение будет искажено
* AutoSize - позволяет автоматически изменять размер компонента в соответствии с размером изображения
* Center - позволяет определять расположение изображения в поле компонента Image по горизонтали, если ширина картинки меньше ширины компонента. Если свойства равно False, то изображение прижато к правой границе, если True то изображение располагается по центру
* Canvas - поверхность, позволяющая вывести графику
* Transpa­rent - указывает прозрачный цвет фона изображения

### Компонент Shape.

Компонент Delphi Shape он предназначен для рисования простейших геометрических фигур соответствующим образом заштрихованные или однотонных. Главное свойство этого компонента это — Shape, форма которую может принимать компонент. Это свойство может принимать следующие значения

* stRectangle - прямоугольник
* stRoundRect - прямоугольник с округленными углами
* stEllipse - эллипс
* stSquare- квадрат
* stRoundSquare - квадрат с округленными углами
* stCircle - круг

***

## <a name="14"></a> 14. Компонент Timer.

Компонент Delphi Timer расположен на странице System Палитры Инструментов. Это важный не визуальный компонент, который позволяет задавать в приложении  необходимые задержки времени между выполнением тех или иных действий.

Данный компонент имеет два главный свойства:

* Enabled - включает (TRUE) или выключает (FALSE) работу таймера,
* Interval - задает фиксированный интервал времени в миллисекундах.

***

## <a name="15"></a> 15. Панель переключателей RadioGroup и список выключателей CheckListBox.

### Панель переключателей RadioGroup.

Компонент Delphi RadioButton (переключатель) находиться на странице Standard Палитры Компонентов. Назначение переключателя выбор одного из нескольких возможных, например выбрать пол человека (мужской женский) или способ оплаты (наличные, чеком, кредитной картой).

Он представляет собой белый кружок с текстовой надписью, поясняющей его предназначение. При выборе в середине кружка появляется черная отметка. Ее можно убрать выбрав другой переключатель. Свойство Caption является текстовым заголовком переключателя. Значение свойства Alignment задает, где расположится заголовок переключателя:

* taRightJustify — справа (это значение принято по умолчанию),
* taLeftJustify — слева.

### Список выключателей CheckListBox.

CheckListBox выглядит как ListBox, но около каждой строки имеется индикатор, который пользователь может переключать, в том числе и программно. Все свойства компонета CheckListBox как списка аналогичны ListBox. Состояние индикаторов определяют два свойства - индексированные массивы: State и Checked, каждый элемент которых соответствует индексу строки, устанавливаемые в том числе и программно. При каждом щелчке пользователя на индикаторе его состояние изменяется, проходя в общем случае последовательно три значения: выделение(появление черной галочки), промежуточное (серое окно индикатора и серая галочка) и не выделенное ( пустое окно индикатора). Этим трем состояниям соответствуют три значения свойства компонента State (при AllowGrayed=true):

    CbChecked, CbGrayed, сbUnchecked

При AllowGrayed=false (значение по умолчанию) допускаются только два состояния: выделенное и не выделенное.

Компонент Delphi ListBox служит для отображения списков строк. Каждая строка ListBox хранит данные в формате String

ListBox представляет собой упорядоченную совокупность связанных между собой элементов, являющиеся текстовыми строками. Пример списков можно посмотреть в MS Office, например, для отображения размера шрифтов. ListBox не позволяет редактировать список пользователю сделать это можно только программно. Компонент ListBox может обращаться к текстовому файлу для считывания информации и для сохранения строк в текстовый файл.

***

## <a name="16"></a> 16. Панель (зависимых переключателей RAdioGroup).

Компонент RadioGroup представляет собой специальный контейнер, предназначенный для размещения зависимых переключателей класса TRadioButton. Группа переключателей RadioGroup может содержать другие элементы управления, например, независимый переключатель CheckBox или однострочный редактор edit.

Каждый размещаемый в нем переключатель помещается в специальный список Items и доступен по индексу, что упрощает обслуживание группы. После размещения компонента на форме он пуст. Чтобы создать в нем хотя бы один переключатель, следует раскрыть редактор списка Items и ввести хотя бы одну строку: строки Items используются как поясняющие надписи справа от переключателей, а их количество определяет количество переключателей в группе. Отчет строк в массиве начинается с нуля: Items\[0\], Items\[1\] и т.д. Для манипуляции со строками можно использовать такие методы, как Add и Delete.

Доступ к отдельному переключателю можно получить через свойство ItemIndex типа Integer, содержащее позицию переключателя, выбранного в группе в текущий момент. Это свойство можно использовать для выбора отдельного переключателя или для определения, какой из переключателей является выбранным. По умолчанию свойство ItemIndex имеет значение -1 и не выбран ни один из переключателей.

***

## <a name="17"></a> 17. Список независимых выключателей CheckListBox.

Список выключателей CheckListBox подобен панели переключателей RadioGroupв том смысле, что оба эти компонента предназначены для группирования более простых элементов управления: RadioGroupобъединяет зависимые переключатели, a CheckListBox - независимые выключатели.Отдельно взятый выключатель (флажок) представляет собой компонент CheckBox, являющийся экземпляром класса TCheckBox. Он может находиться в одном из двух (реже - трех) состояниях:

* включен в выключатель помещается символ «галочка»;
* выключен выключатель пуст;

***

## <a name="18"></a> 18. Список ListBox. Комбинированная строка ввода ComboBox.

### Список ListBox


Компонент Delphi ListBox служит для отображения списков строк. Каждая строка ListBox хранит данные в формате String

ListBox представляет собой упорядоченную совокупность связанных между собой элементов, являющиеся текстовыми строками. Пример списков можно посмотреть в MS Office, например, для отображения размера шрифтов. ListBox не позволяет редактировать список пользователю сделать это можно только программно. Компонент ListBox может обращаться к текстовому файлу для считывания информации и для сохранения строк в текстовый файл.

### Комбинированная строка ввода ComboBox.

Компонент Delphi ComboBox представляет собой комбинацию списка строк ListBox со строкой ввода Edit. При этом "список строк" компонента Delphi ComboBox вначале скрыт, и раскрывается при щелчке мышкой по треугольничку раскрытия, который находится справа в строке ввода.


***

## <a name="19"></a> 19. Создание меню. Главное меню. Контекстное меню PopupMenu.

### Создание меню.

Для создания главного меню в VCL предусмотрен компонент MainMenu, а для контекстного – PopupMenu. Оба они происходят от класса TMenu, и имеют некоторые общие свойства. В частности, свойство AutoHotkeys определяет, должны ли автоматически назначаться символы для быстрой навигации по меню (вы видите их подчеркнутыми при нажатой клавише Alt). А свойство AutoLineReduction определяет, должны ли автоматически удаляться повторяющиеся строки-разделители. Оба эти свойства могут принимать значения maAutomatic и maManual.

Так же у них присутствуют свойства Images, позволяющие привязать к меню коллекцию изображений, и Items, являющиеся хранилищем самих пунктов меню.

### Главное меню.

 Компонент Delphi MainMenu предназначен для добавления к программе главного меню, элемента, без которого не обходится ни одно из приложений для Windows.
Чтобы добавить к программе Delphi главное меню, нужно расместить на Форме в произвольном месте компонент MainMenu. Компонент MainMemu невизуальный, то есть, хотя и отображается на прототипе Формы как небольшой квадрат, в работающей программе не будет виден. Опции главного меню создаются с помощью специального редактора. Редактор меню вызывается с помощью двойного щелчка по компоненту MainMenu. Первоначально меню пустое, но имеет один выделенный элемент.

### Контекстное меню PopupMenu.

Контекстное меню (PopupMenu), вызываемое в приложении Windows по щелчку правой кнопкой мыши, является стандартной и удобной возможностью многих программ. Delphi компонент PopupMenu предназначен для создания таких контекстных меню. Контекстное меню из-за способа своего появления называют ещё всплывающим меню.

Delphi компонент PopupMenu почти не отличается от компонента MainMenu и также является невизуальным. Но в отличие от Главного меню, которое одно на Форме, всплывающие меню могут быть у каждого объекта, размещённого на Форме. Поэтому нужно разместить на Форме и запрограммировать столько компонентов PopupMenu, сколько контекстных меню предполагается использовать в программе. Кроме того, контекстное меню не имеет нескольких пунктов верхнего уровня, так как все его пункты располагаются в одном вертикальном столбце.

***

## <a name="20"></a> 20. Класс TStringGrid.

StringGrid - компонент для отображения различных данных в табличной форме. Как следует из названия, ячейки компонента StringGrid Delphi могут содержать данные, имеющие тип String, а также отображать графику.

Таблица StringGrid состоит из выделенных серым FixedCols и FixedRows - зафиксированных ячеек-заголовков, и обычных, белых ячеек. Содержимое Fixed ячеек недоступно редактированию, и меняется только программно. За возможность редактирования обычных ячеек отвечает одно из значений свойства Options.

Итак, компонент StringGrid имеет возможность адресации каждой отдельной ячейки по номеру столбца и строки. Содержимое ячейки (i, j), где где i - номер столбца, j - номер строки, имеет вид

    StringGrid1.Cells[i, j]

и доступно как для чтения, так и для записи. Здесь, как и всегда, номера столбцов ( i ) и строк ( j ) отсчитываются от 0.

***

## <a name="21"></a> 21. Диалоговые окна.

Диалоговое окно — вспомогательное окно, содержащее кнопки и
другие элементы управления, при помощи которых можно выполнить ту или иную
команду или задачу.

Виды диалоговых окон:

* окна ввода информации;
* окна вывода информации (окна сообщений).

***

## <a name="22"></a> 22. Форма. Характеристики формы. Создание формы. Активность формы. События формы. Управление видимостью. Получение фокуса. Перерисовка формы. Закрытие формы. Обработка событий клавиатуры. Оформление формы. Слить формы.

### Форма.

Форма – это важнейший визуальный компонент, который представляет собой видимое окно Windows. В системе Delphi форма является компонентом, который служит контейнером для всех других компонентов.
Приложение может иметь несколько форм, одна из которых считается главной и при запуске программы отображается первой.
Форма может быть модальной и немодальной. Немодальная форма позволяет без ее закрытия переключиться в другую форму приложения, а модальная форма требует обязательного закрытия перед обращением к любой другой форме приложения.

В Windows есть два основных типа приложений: однодокументные (SDI – однодокументный интерфейс), и многодокументные (MDI – многодокументный интерфейс). Однодокументные приложения состоят из одного или нескольких независимых друг от друга форм. Многодокументное приложение может работать одновременно с несколькими различными документами. В таких приложениях главное окно содержит дочерние окна, размещаемые в его пределах.

Если одна форма выполняет какие-либо действия с другой формой, то в списке uses раздела Implemention модуля первой формы должна быть ссылка на модуль второй формы.
Ссылку на модуль другой формы можно устанавливать программно, а можно и автоматически. Для этого нужно выбрать команду File-Use Unit (Файл-Использовать модуль) и в диалоговом окне выбрать соответствующий подключаемый модуль.

***

## <a name="23"></a> 23. Рамка. Кнопки. Размещение и размер. Полосы прокрутки. Взаимодействие форм.

***

## <a name="24"></a> 24. Модальные формы. Диалоговые окна. Стандартные диалоговые окна. Шаблоны форм.

***

## <a name="25"></a> 25. Приложение.

***

## <a name="26"></a> 26. Работа с файловой системой. Диск. SysUtils. Каталоги. SysUtils. Файлы. DriveComboBox. DirectoryListBox. FileListBox. FilterComboBox.

***

## <a name="27"></a> 27. Обработка исключений. Классы исключений. Наиболее часто используемые исключения.

***

## <a name="28"></a> 28. Обработка исключений. Глобальная обработка. Локальная обработка. Вызов исключений.

***

## <a name="29"></a> 29. Технологиия программирования и основные этапы ее развития.

***

## <a name="30"></a> 30. Проблемы разработки сложных программных систем.

***

## <a name="31"></a> 31. Блочно-иерархический подход к созданию сложных систем.

***

## <a name="32"></a> 32. Жизненный цикл и этапы разработки программного обеспечения.

***

## <a name="33"></a> 33. Эволюци моделей жизненого цикла программного обеспечения.

***

## <a name="34"></a> 34. Ускорение разработки программного обеспечения. Технология RAD.

***

## <a name="35"></a> 35. Тестирование и отладка.

***
