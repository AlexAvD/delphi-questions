## Вопросы

1. [Динамическая память и указатели.](#1)
2. [Модули](#2)
3. [Основы визуального программирования. Интегрированная среда разработки Delphi.](#3)
4. [Классы. Инкапсуляция. Наследование. Полиморфизм. Поля. Методы. (Статические, динамические, конструктор и деструктор).](#4)
5. [Объявление класса. Свойства. События. Область видимости элементов класса.](#5)
6. [Компоненты. Класс TObject. Класс TPersistent. Класс TComponent.](№6)
7. [Класс TControl.](#7)
8. [Класс TWinControl. Класс TGraphicControl.](#8)
9. [Компоненты Label, Button BitBtn, SpeedButton.](#9)
10. [Класс TCustomEdit. Edit.](#10)
11. [Текстовый редактор Memo. Класс TStrings.](#11)
12. [Классы и компоненты, предназначенные для создания изображения. Класс TFont. Класс TPen. Класс TBrush. Класс TCanvas.](#12)
13. [Компонент Image. Компонент Shape.](#13)
14. [Компонент Timer.](#14)
15. [Панель переключателей RadioGroup и список выключателей CheckListBox.](#15)
16. [Панель (зависимых переключателей RAdioGroup).](#16)
17. [Список независимых выключателей CheckListBox.](#17)
18. [Список ListBox. Комбинированная строка ввода ComboBox.](#18)
19. [Создание меню. Главное меню. Контекстное меню PopupMenu.](#19)
20. [Класс TStringGrid.](#20)
21. [Диалоговые окна.](#21)
22. [Форма. Характеристики формы. Создание формы. Активность формы. События формы. Управление видимостью. Получение фокуса. Перерисовка формы. Закрытие формы. Обработка событий клавиатуры. Оформление формы. Слить формы.](#22)
23. [Рамка. Кнопки. Размещение и размер. Полосы прокрутки. Взаимодействие форм.](#23)
24. [Модальные формы. Диалоговые окна. Стандартные диалоговые окна. Шаблоны форм.](#24)
25. [Приложение.](#25)
26. [Работа с файловой системой. Диск. SysUtils. Каталоги. SysUtils. Файлы. DriveComboBox. DirectoryListBox. FileListBox. FilterComboBox.](#26)
27. [Обработка исключений. Классы исключений. Наиболее часто используемые исключения.](#27)
28. [Обработка исключений. Глобальная обработка. Локальная обработка. Вызов исключений.](#28)
29. [Технологиия программирования и основные этапы ее развития.](#29)
30. [Проблемы разработки сложных программных систем.](#30)
31. [Блочно-иерархический подход к созданию сложных систем.](#31)
32. [Жизненный цикл и этапы разработки программного обеспечения.](32)
33. [Эволюци моделей жизненого цикла программного обеспечения.](#33)
34. [Ускорение разработки программного обеспечения. Технология RAD.](#34)
35. [Тестирование и отладка.](#35)

*** 

## <a name="1"></a> 1. Динамическая память и указатели.

Динамические переменные - это переменные, память под которые выделяется во время выполнения 
программы.
Основным механизмом для организации динамических данных является выделение в специальной области памяти, называемой « heap-областью» или «кучей», непрерывного участка подходящего размера и сохранения адреса начала этого участка в специальной переменной,  называемой, ссылочной переменной  или ссылкой или указателем.
Ссылочная переменная (указатель) – переменная, предназначенная для хранения адреса переменной, расположенной в динамической области памяти (heap – области или «куче»).
Сам указатель располагается в статической памяти.

    Type 
        DinMas=array[1..10000] of real;
        p1=^integer; 
        p2=^real; 
        P3=^DinMas;
    Var 
        A,B,C:p1; 
        X,Y,Z:p2; 
        M:p3;
        P:^char;
        T:^integer;

***

## <a name="2"></a> 2. Модули.

Модуль - это автономно компилируемая программная единица, содержащая константы, типы, переменные, процедуры функции.
Работа с модулем состоит из двух частей: написание и компиляция;
Достоинства модулей: модули избавляют от необходимости работать с второстепенным кодом, а сосредоточится на главном.
Недостатки: позднее обнаружения ошибок на этапе выполнения.

    Unit <name>;
    Uses <list of modules>; // Используемый модуль
    interface <constants, variables, types, имена процедуры функции которые будут видные пользователю >;
    implementation <local variables, constants, types, процедуры функции и реализация интерфейсных процедур и функций>;
    initialization <операторы которые претворяют запуск модуля>;
    finalization <операторы предшествующие окончанию работы модуля>;
    end.


***

## <a name="3"></a> 3. Основы визуального программирования. Интегрированная среда разработки Delphi.

Системы программирования – это комплекс инструментальных программных средств, предназначенных для работы с программами на одном из языков программирования.

В настоящее время разработка любого системного и прикладного программного обеспечения осуществляется с помощью систем (сред) программирования, в состав которых входят:

* Компилятор (Compile), предназначенный для компиляции или интерпретации исходного текста программы в машинный код с диагностикой синтаксических и семантических (логических) ошибок; 
* Текстовый редактор (Edit), осуществляющий функции записи и редактирования исходного текста программы;
* Средства редактирования, компоновки и загрузки программ;
* Макроассемблеры (машинно-ориентированные языки);
* Загрузчик программ(Load), позволяющий выбрать из директория нужный текстовый файл программы;
* Запускатель программ (Run), осуществляющий процесс выполнения программы;
* Отладчик (Debug), выполняющий сервисные функции по отладке и тестированию программы;
* Диспетчер файлов (File), предоставляющий возможность выполнять операции с файлами: сохранение, поиск, уничтожение и т.п.

Кроме выше перечисленных составляющих среда программирования может включать значительное число компонентов по работе с базами данных, по созданию графических интерфейсов, утилит разного назначения. Все вместе работает как интегрированная среда разработки программного обеспечения.

Интегрированная среда разработки (Integrated Development Environment, IDE) Delphi – это система, которая имеет все, необходимое для проектирования, запуска и отладки приложения. 

**Раскладка экрана Delphi**

Главное окно (Delphi – Project1), как и в большинстве других приложений Windows, имеет главное меню, обладающее свойством функциональной полноты (все возможности программного комплекса можно найти в главном меню)

Наиболее часто встречающиеся функции выделены в панели инструментов их десять. Находятся они в меню View=>ToolBars или в контекстном меню панели инструментов. Как и в большинстве приложений Windows, панели инструментов IDE Delphi содержат пиктограммы, с помощью которых можно запускать различные команды. Чтобы узнать назначение любой пиктограммы, нужно установить на ней указатель мыши и подержать его неподвижно до появления всплывающей подсказки.

Панели инструментов включают:

* Standard Стандартная панель инструментов содержит пиктограммы общих задач, (открытие, сохранение и создание проектов Delphi и ассоциированных с ними файлов).
* Debug. Панель инструментов отладки используется для интерактивного тестирования и отладки программ. Она обеспечивает быстрый доступ к командам отладчика Delphi, доступные также из меню Run (Выполнение). Отладчик Delphi представляет собой утилиту времени разработки, т.е. ее можно использовать непосредственно в среде разработки Delphi при работе над исходным кодом.
* Desktop. Панель инструментов для настройки рабочего стала. С ее помощью программист может манипулировать раскладками рабочего стола, определяющими видимость, размеры, стыковку и расположение окон, а также состав инструментов Delphi. Панель рабочего стола содержит список  имеющихся раскладок рабочего стола. Можно сохранить текущую раскладку и присвоить ей какое-либо имя. Если одну из раскладок выделить, то при следующем запуске Delphi она будет выведена на экран.
* Custom. встроенный справочник.
* Align. Панель, позволяющая выравнивать выделенные визуальные компоненты.
* Spacing. Панель, позволяющая распределение выделенных визуальных компонентов.
* Position. Панель позиционирования (на передний план, на задний план и др.);
* View. Позволяет создать новый модуль, создать новую форму, поменять местами конструктор формы и редактор с текстом модуля соответствующего форме.

**Окна IDE.**

При работе в среде визуального проектирования работа распределяется на две отдельные задачи
Первое на работу с визуальными конструкторами форм на формах размещаются различные элементы управления (кнопки, надписи, переключатели и др.) обеспечивающие функциональность приложения.

Второе на работу с программным кодом, обслуживающим события форм.

После загрузки интерфейс Delphi имеет пять (шесть) основных окон: 

* конструктор форм
* редактор кода
* структура объектов в виде дерева 
* инспектора объектов
* менеджер проекта
* палитра компонентов.

***

## <a name="4"></a> 4. Классы. Инкапсуляция. Наследование. Полиморфизм. Поля. Методы. (Статические, динамические, конструктор и деструктор).

### Классы.

**Классы** – это типы специального вида, которые содержат поля, методы и свойства. 
Классы, как и любые другие типы, служат образцами для создания  конкретных экземпляров. 
Конкретные  экземпляры класса называются объектами. 


Объявление класса:

    Type 
        TmyCl=class(Tobject)
            Fint:integer;
            Fstr:string;
            Function Func1(a:real):integer;		
            Procedure Proc1;
        End;
    Var 
        MyClass:TmyCl;  
    Function TmyCl.Func1(a:real):integer;
            Begin result:=a* Fint ; end;
    Procedure TmyCl.Proc1;
            Begin …; end;
    Begin 
        MyClass:=TmyCl.create;
        MyClass.Fint:=10;
        MyClass. Proc1;
        MyClass.Free;
    End.

### Инкапсуляция.

**Инкапсуляция** – это объединение в одно целое трех сущностей: полей, методов и свойств.

Поля уникальные, методы общие. Инкапсуляция предполагает, что поля, методы и свойства в классе функционально самодостаточны для решение какой либо задачи. Инкапсуляция предполагает разграничение уровня доступа разработчиков разного уровня, потому-что: 

* пользователи класса не должны видеть подробности которыми оперирует разработчик; 
* прямой доступ к поля хотя и возможен, но нежелателен;

Инкапсуляция позволяет изолировать класс от остальных частей программы, сделать его самодостаточным для решения конкретной задачи. 
Инкапсуляция предполагает разграничение доступа разработчиков разного уровня к различным членам класса.

### Наследование.

Любой класс может быть порожден от другого класса. Порожденный 
класс автоматически наследует все члены родителя, но может и пополнять их.

### Полиморфизм.

**Полиморфизм** – это возможность в классах потомках переопределять (перекрывать) методы родителей.

### Поля.

**Поля** – это данные.

### Методы.

**Методы** – это процедуры, обрабатывающие данные.
Инкапсулированные в классе процедуры и функции называются методами.
В ООП различаются следующие виды методов:

* Методы класса 
* Конструктор и деструктор 
* Виртуальные
* Динамические
* Абстрактные 
* Перегружаемые

### Конструктор и деструктор.

В состав любого класса входят два специальных метода – конструктор и деструктор. 
В классе TОbject конструктор называется create деструктор destroy. 
Конструктор и деструктор – это функция и процедура, но в виду важности они объявляются с помощью зарезервированных слов Constructor Destructor.

    Type
        TmyCl=class(TObject)
	        …
        end;
    Var
        Ob1: TmyCl; //выделяет указатель 4 б, cначалa хранит nil
    Для разворачивания же объекта в динамической памяти используется метод класса конструктор (для Tobject это Create) в таком виде:
    Ob1:= TmyCl.Create;


***

## <a name="5"></a> 5. Объявление класса. Свойства. События. Область видимости элементов класса.

### Объявление класса.

    Type 
        TmyCl=class(Tobject)
            Fint:integer;
            Fstr:string;
            Function Func1(a:real):integer;		
            Procedure Proc1;
        End;

### Свойства.

**Свойства** – это механизм доступа к данным.

    Type
        TMan=class(Tobject)
            private
                FVozrast:integer;
            protected
                Function GetVozr:integer;
                Procedure SetVozr(r:integer); 
            public 
                Property Vozrast:integer read GetVozr write SetVozr; // свойство
        End;

    Var 
        мan: TМan;
    Function TМan.GetVozr:integer;
        Begin result:= FVozrast; end;
    Procedure TМan.SetVozr(r:integer); 
        Begin 
            if r<100 then FVozrast:=r else exit;
        end;

### События.

Событие – это то, что происходит в результате работы компьютера. На низком уровне это изменения, (нажатие кнопки, исход времени, деление на ноль) вызывающие прерывания.
С точки зрения языка событие - это свойство процедурного типа, его значением является указатель на некоторый метод. 

    Type 
        TControl = class (TComponent) 
            Private
                FOnDblClick: TNottifyEvent ;
                ……………………..
            Protected
                property OnDblClick: TNottifyEvent  read  FOnDblClick  write  FOnDblClick;
                ………………………
                end; 
        TNotifyEvent = Procedure(Sender:TObject) of object;

### Область видимости элементов класса.

В Delphi есть четыре модификатора разграничения доступа:

* **public**
* **published**
* **potected**
* **private**

Модификатором **public** объявляют (помечают ) члены класса видимые везде. 
А именно, в любой программе и в любом модуле, которые имеют доступ к нашему модулю, (т.е. где наш модуль объявлен в разделе USES).
Модификатором **published** объявляют члены класса видимые везде, но более того, свойства помещенные в эту секцию видимы еще и в инспекторе объектов. 
Секция, не имеющая модификатора доступа, по умолчанию считается published
Модификатором **protected** объявляют члены класса доступные методам самого класса и их потомкам.
Модификатором **private** объявляют члены класса видимые только в модуле, где описан класс, т.е. это локальные описания.

***

## <a name="6"></a> 6. Компоненты. Класс TObject. Класс TPersistent. Класс TComponent.

### Класс TObject.


Предок всех классов. Класс абстрактный. Обеспечивает возможность создания и разрушения объектов. 	
Для этого определены следующие методы.
Constructor Create – выделяет динам память, инициализацию не делает, т.к. перегружается.
Destructor Destroy; virtual; - освобождает выделенную память.
Procedure Free – проверяет существование и, если память выделялась, то освобождает ее.
Методы класса:

* ClassName: shortString; - возвращает имя класса данного объекта
* ClassNameIs (const Name:string):Boolean; - данный класс совпадает Name
* InheritsForm(aClass:Tclass):Boolean; - является ли класс предком дан кл
* InstanceSize:Longint; - возвращает размер класс или объекта.


### Класс TPersistent.

Его объекты инкапсулируют в себе некоторый носитель информации. Память или дисковые файлы. 
Методы класса:

* Procedure Assign(Source:Tpersistent); - присваивает данному объекту данные, содержащиеся в объекте с именем Source
* Function GetNamePath: string; dynamic; - возвращает строку, содержащую имя объекта.
* Function GetOwner: TPersistent; dynamic;- возвращает указатель на владельца объекта.


### Класс TComponent.

Вершина иерархии компонентов. Потомки его - невизуальные компонент (TApplication, Tform таймер, меню, диалоговые окна). 

Свойства класса:

* Name  (строка ) – имя компонента. При помещении компонента на форму присваивается стандартное имя Label1, Edit1, которое можно заменить на более осмысленное, при этом имя должно быть правильным идентификатором.
* Tag: Longint; - некоторое число, которым разработчик может распоряжаться по усмотрению.

В классе TComponent вводится концепция принадлежности, которая распространяется на всю VCL. Суть: 
любой компонент Делфи является собственностью другого компонента. 
при разрушении компонента владельца автоматически разрушается принадлежащие ему компоненты. 
Свойства реализующие концепцию принадлежности:

* ComponentCount:Integer; - количество компонентов во владении
* ComponentIndex:Integer; - номер компонента в списке владельца (нумерация с нуля).
* Components \[Index:Integer\]:TComponent; - список компонен-тов, для которых данный является владельцем.
* Owner: TComponent; - содержит указатель на компонент владелец для текущего компонента. 

Методы класса:

* Constructor Create (AOwner: TComponent);virtual;  - создает объект данного класса, помещает ссылку на себя в массив Components, своего владельца, имя которого указано в AOwner.
* Destroy Tcomponent;- удаляет из памяти компоненты данного владельца.
* Procedure InsertComponent(Acomponent: TComponent); - вставляет новый компонент с именем Acomponent.
* Procedure RemoveComponent(Acomponent: TComponent); - удаляет компонент Acomponent. 

***

## <a name="7"></a> 7. Класс TControl.

Потомки этого класса называются элементами управления.
Это визуальные компоненты  с их помощью информация выводится на экран.
В потомках TControl вводится понятие родительского элемента управления суть его в следующем:
Каждый элемент управления может быть помещен в груп-пирующий элемент. Дочерние не могут выходить за рамки роди-тельского, при перемещении родительского перемещаются и дочерние.
Дочерний элемент использует некоторые родительские свойства (цвет, шрифт). Визуально изображение родительского и дочернего на экране получает единый хороший стиль.
В качестве родительского может выступать только оконный элемент управления, т.е. потомок TWinControl, дочерние элементы управления могут быть любыми.
Не следует путать владельца и родителя

***

## <a name="8"></a> 8. Класс TWinControl. Класс TGraphicControl.

### Класс TWinControl.

Потомок TControl – является базовым для создания оконных элементов управления. 
Такие элементы во время выполнения программы могут получать фокус ввода,  реагируют на события, возникающие при использовании клавиатуры. Наличие окна позволяет активизировать элемент управления во время выполнения программы. 
С каждым оконным элементом управления связано окно Windows, определяемое специальным числовым идентификатором – дескриптором окна.
В этом классе  завершается определение характеристик связи родительский дочерний, начатое в TControl  (только оконный элемент может быть контейнером для содержания других компонентов).

### Класс TGraphicControl.

Потомки этого класса имеют общее название – графические элементы управления. 
Потомки TGraphicControl: фокус ввода не получают, не могут быть родительскими для других, 
реагируют на события мыши. 
Их назначение – вывод информации на экран, улучшение внешнего вида.Представители: Label, Shape- фигура, PaintBox – паненль рисования, Imege.
	
Property Canvas: TCanvas; - (канва - холст) средства предназ-наченные для создания на экране графического изображения. 

Procedure Paint; - рисует изображение графического элемента управления. В потомках обычно переопределяется, чтобы учесть специфику.

***

## <a name="9"></a> 9. Компоненты Label, Button BitBtn, SpeedButton.

### Label.

Компонент Label предназначен для отображения статического текста, то есть надписей и меток на Форме, которые не меняются в течение всего времени работы программы.

Иерархия TObject-TPersistent-TComponent-TControl-TGraphicControl-TcustomLabel. Страница палитры Standard.

Предназначена для вывода на экран текстовой информации (названия разъяснения). 

Основным свойством является caption (TControl). Туда помещается выводимый текст.

    Label1.caption:=‘выводимый текст’;

Обрабатывает события связанные с использованием мыши/
По умолчанию для метки основным является событие OnClick. 


### Button BitBtn.

Это оконный элемент управления.Множество стандартных кнопок типа Ok Cancel, Yes, No и кнопки с рисунком.

* Property Kind:TbitBtnKind  предопределенные виды кнопок, выбираемых с помощью свойства  Kind.

Константы:

bkCustom   на кнопке отсутствует изображение, его можно загрузить самостоятельно
bkOK-  глиф «зеленая галочка» и текст ОК Свойство  * Default-true, ModalResult-mrOK
bkCancel //-//-//,  bkYes//-//-//,  bkNo//-//-//,  bkHelp, bkClose, bkAbort,  bkRetry,  blIgnore,  bkAll

Glyph:TbitMap Определяет растровый рисунок кнопки ( по умолчанию кнопка не содержит рисунка). Рисунок может содержать до трех отдельных изображений (глифов). Это зависит от  ее текущего состояния

1-ое изображение отображается , если кнопка не нажата (по умолчанию)

2-ое изображение, если кнопа неактивна и не может быт  выбрана.

3-е изображение, когда кнопка нажата (выполнен щелчок)

NumGlyph:TNumGlyphs  Указывается количество изображений ( по умолчанию 1)

Layout:TbuttonLayout управляет расположением изображения на поверхности кнопки относительно текста.

Margin:Integer можно управлять выравниванием глифа и текста относительно сторон кнопки. Это свойство задает расстояние в пикселах между стороной кнопки и изображением ( по умолчанию –1 , т.е. в центре).

Spacing:Integer определяет размер ( в пикселах) промежутка , отделяющего глиф от текста ( по умолчанию=4)


### SpeedButton.

SpeedButton: TgraphicControl кнопка быстрого доступа. Неоконный элемент управления. 

Похож на bitButton. Glyph, NumGlyph, Layout и тд те же. Кнопка  SpeedButton может использоваться как переключатель. Поэтому, помимо обычного  и нажатого состояния она имеет третье состояние - утопленное (включенное).

Свойства:

* Down:Boolean определяет включена ли кнопка или нет. 


***

## <a name="10"></a> 10. Класс TCustomEdit. Edit.

###  Класс TCustomEdit.

Позволяет вводить с клавиатуры и редактировать различную информацию. Имеются возможности выделения, копирования, удаления, вставки текста, скроллинга и т. д.

* TObject-TPersistent-TComponent-TControl-TWinControl-TCustomEdit.
* Property AutoSelect:Boolean; - ИСТИНА по умолчанию, текст выделяется при активизации редактора.
* Property borderStyle; - вид границы.
* Property MaxLength:Integer; - максимальное число символов, которые можно поместить в редакторе. Если 0 (по умолчанию), то любое число символов.
* Property ReadOnly: Boolean; - по умолчанию ЛОЖЬ, только ли для чтения.
* Property PasswordChar:Char; - задает символ, который будет выводиться при вместо реально вводимых символов, как при вводе пароля.
* Procedure Clear; virtual;  - удаляет текст, помещенный в редактор.
* Procedure ClearSelection; - удаляет выделенный фрагмент.
* Procedure CopyToClipboard; - копирует в буфер.
* Procedure CutToClipboard; - вырезает в буфер.
* Procedure PasteFromClipboard; - вставляет.
* Procedure SelectAll; - выделяет весь текст в редакторе. 


### Edit

Компонент Delphi Edit представляет собой однострочное текстовое поле, служащее для ввода данных пользователем. Основным свойством компонента Delphi Edit, передающим введённую информацию, является свойство Edit1.Text типа String.

TObject-TPersistent-TComponent-TControl-TWinControl-TCustomEdit-TEdit.    
Страница палитры Standart.

Основным свойством строки ввода является текст.

* Property Text: TCaption; - символьная строка в редакторе. 
Type TCaption=string;

Может быть помещена либо на этапе конструирования, либо на этапе выполнения, чаще для ввода информации.
Это оконный элемент управления и он обрабатывает все события от мыши и клавиатуры, а так же событие OnChenge

* Type OnChange: TNotifyEvent; - возникает при изменении текста строки ввода.

***

## <a name="11"></a> 11. Текстовый редактор Memo. Класс TStrings.

### Текстовый редактор Memo.


    TObject-TPersistent-TComponent-TControl-TWinControl-TCustomEdit-ЕСustomMemo.
    
* Property Lines:TStrings; - задает список строк, помещенных в редактор.

        Type TScrolStyle=(ssNone,ssHorizontal,ssVertical,ssBoth);

* Property ScrollBars:TScrollBars; - задает наличие линеек скроллинга.
* Property WantReturns:Boolean; ­ - ИСТИНА, то по клавише Enter происходит переход на новую строку текста, иначе переход делается Ctrl+Enter.

Текстовый редактор Memo обрабатывает все события связанные с мышью и клавиатурой, а также событие OnChange. 

Компонент Delphi Memo это простой текстовый редактор. Delphi Memo позволяет вводить многострочный текст с клавиатуры, загружать его из файла, редактировать и сохранять в файл текстового формата.

Свойства memo:

* Name - Имя компонента. Используется в программе для доступа к свойствам компонента
* Text - Текст, находящийся в поле Memo. Рассматривается как единое целое
* Lines - Текст, находящийся в поле Memo. Рассматривается как совокупность строк. Доступ к строке осуществляется по номеру
* Lines.Count - Количество строк текста в поле Memo
* Left - Расстояние от левой границы поля до левой границы формы
* Top - Расстояние от верхней границы поля до верхней границы формы
* Height - Высоту поля
* Width - Ширину поля
* Font - Шрифт, используемый для отображения вводимого текста
* ParentFont - Признак наследования свойств шрифта родительской формы



### Класс TStrings.

TObject-TPersistent-TStrings

Абстрактный класс инкапсулирует поля и методы для работы с наборами строк. Особенностью TStrings является, то что элементами наборов являются пары строка объект. Строка – строка символов, а объект – объект любого класса. 

* Property Count:integer; - определяет число элементов в списке.
* Property Objects\[Index:integer]:TObject; - определяет указатель на объект, ассоциированный со строкой с номером index.
* Property Strings\[Index:integer]:string; - определяет строку с номером index, начиная с нуля.
* Property Text:string;- содержит все строки списка, включая разделители (ВК,ПС #13 #10).

**Методы, определенные в классе.**

* Function Add(const S:string):integer;virtual; - добавляет строку S в список и возвращает порядковый номер этой строки в списке.
* Function AddObject(const S:string; AObject:TObject):integer;virtual; - добавляет строку S и связанный с ней объект AObject в список и возвращает индекс строки и объекта в списке.
* Procedure AddString(string:TString);virtual; - добавляет список другого объекта String класса TString к текущему списоку.
* Procedure Clear;virtual;abstract; - удаляет все строки и указатели на объекты из списка.
* Procedure Delete(Index:integer);virtual;abstract; - удаляет из списка элемент с номером Index.
* Procedure Exchange(index1,index2:integer);virtual; - меняет местами два элемента списка с номерами.. 
* Procedure Move(CurIndex,NewIndex:integer);virtual;- перемещает элемент списка из позиции ..в
* Procedure Insert(index:integer; const S:string);virtual;abstract; - вставляет в список строку S номером Index.
* Procedure LoadFromFile(const FileName:string);virtual; загружает список из файла с именем FileName.
* Procedure SaveToFile(const FileName:string);virtual; - помещает список в файл с именем FileName.


***

## <a name="12"></a> 12. Классы и компоненты, предназначенные для создания изображения. Класс TFont. Класс TPen. Класс TBrush. Класс TCanvas.

### Классы и компоненты, предназначенные для создания изображения.

Есть несколько классов, позволяющих выводить графические изображения на поверхность компонентов TCanvas, TForm имеется событие OnChange, возникающее при изменении графического объекта. Есть  компоненты, специально предназначенные для графических изображений: Image, Shape, PaintBox.

### Класс TFont.

Класс TFont задает характеристики шрифта, которым отображает-
ся текст в графической компоненте. Шрифт, который используется для
вывода текста, определяется значением свойства Font соответствую-
щего объекта Canvas. Для вывода текста на поверхность графического
объекта используются методы TextOut() и TextRect(), допускаю-
щие только горизонтальное расположение строк.

Свойства класса TFont:

* Property Charset: TFontCharSet; – набор символов. Для русскоязычных программ это свойство обычно имеет значение DEFAULTCHARSET или RUSSIAN CHARSET. Используйте значение OEMCHARSET для отображения текста MS–DOS (альтернативная кодировка);
* Property Color: TColor; – цвет шрифта;
* Property FontAdapter: IChangeNotifier; – указатель на интерфейс для передачи информации о шрифте в компоненты ActveX;
* Property Handle: hFont; – дескриптор шрифта. Используется при непосредственном обращении к API–функциям Windows;
* Property Height: Integer; – высота шрифта в пикселях;
* Property Name: TFontName; – имя шрифта. По умолчанию имеет значение MS Sans Serif;
* Property Pitch: TFontPitch; – определяет способ расположения букв в тексте: значение fpFixed задает моноширинный текст, при котором каждая буква имеет одинаковую ширину; значение fpVariabel определяет пропорциональный текст, при котором ширина буквы зависит от ее начертания; fpDefault определяет ширину, принятую для текущего шрифта;
* Property PixelPerInch: Integer; – определяет количество пикселей экрана на один дюйм реальной длины. Это свойство не следует изменять, так как оно используется системой для обеспечения соответствия экранного шрифта шрифту принтера;
* Property Size: Integer; – высота шрифта в пунктах (1/72 дюйма). Изменение этого свойства автоматически изменяет свойство Height и наоборот;
* Property Style: TFontStyles; – стиль шрифта. Может принимать значение как комбинацию следующих признаков: fsBold (жирный), fsItalic (кypсив), fsUnderline (подчеркнутый), fsStrikeOut (перечеркнутый).

### Класс TPen.

Характеристики карандаша.

* Property Color;-цвет линии (черный по умолчанию).
* Property Mode;- (перечислимый) стиль цвета, т.е. взаимодействие линии с фоном.
* Property Style;- (перечислимый) стиль линии (сплошная, штриховая).
* Property Width;- толщина рисуемой линии в пикселях.

### Класс TBrush.

Характеристики кисти, которая используется для заливки замкнутых областей.

Property Bitmap;

побитовое отображение изображения, размером 8х8, которое будет использоваться кистью для заполнения замкнутых пространств.

* Property Color;- цвет кисти, по умолчанию – белый.
* Property Style;- орнамент кисти (сплошная, горизонтальные линии, вертикальные и т.д..)


### Класс TCanvas.

Определяет поверхность компонента, используемую для рисования и инструменты для рисования TFont, TPen, Tbrush. Объекты класса TCanvas не являются компонентами, но входят в состав компонентов своими свойствами. Канва состоит из точек – пикселей.

В TCanvas определена система координат.   На канве имеется невидимый графический курсор, который определяет положение карандаша. Рисование примитивов начинается именно с этого положения в процессе рисования оно изменяется.

* Property Pen; - задает карандаш канвы.
* Property Brush; - задает кисть канвы.
* Property Font; - задает шрифт канвы.
* Property Pos; - определяет текущее положение графического курсора.
* Property Pixel\[X,Y:integer]:TColor; - задает цвет пикселя с координатами X,Y.



***

## <a name="13"></a> 13. Компонент Image. Компонент Shape.

###  Компонент Image.

Страница палитры Additional. Используется для размещения на форме картинки. Файл изображения может быть битовой картой (расширение bmp), пиктограммой (ico), метафайлом (wmf). Непосредственный потомок класса TGraphicControl. 

Canvas: Tcanvas  предназначается для формирования изображения на этапе выполнения программы. 

* Center: Boolean;если true, то изображение центре компонента.
* Picture: Tpicture – определяет изображение, помещаемое в компонент.
* Stretch: Boolean -  если значение true, то картинка увеличивается или уменьшается до размеров компонента.

Image обрабатывает все события от мыши.

### Компонент Shape.

Страница палитры компонентов Additional.
Экземплярами класса являются компоненты фигуры – круги, эллипсы, прямоуг и т.д.

Свойства 

* Brash:tBrash – кисть для закрашивания поверхности фигуры.
* Pen:Tpen  - карандаш для рисования контура фигуры.
* Shape:Tshape – определяет фигуру выводимую на экран.
Событием по умолчанию является OnDragDrop. 


***

## <a name="14"></a> 14. Компонент Timer.

Страница System.

Предназначен для инициирования какой либо операции через заданные промежутки времени. Невизуальный компонент.

Свойства 

* Enabled: Boolean; - если true, то реагирует на собственное событие OnTimer.
* Interval: cardinal; - интервал в милисекундах после которого начинается событие OnTimer.

Событие OnTimer возникает по истечении интервала времени.
Является событием по умолчанию. 


***

## <a name="15"></a> 15. Панель переключателей RadioGroup и список выключателей CheckListBox.

### Панель переключателей RadioGroup.

Страница Standart. Это общий случай переключателей Radiobutton. Панель переключателей позволяет создать группу зависимых переключателей и определить какой из них нажат.

Свойства панели переключателей:

* Items:TString;-содержит список названий переключателей.
* ItemIndex:integer; - порядковый номер выделенного переключателя. Нумерация с нуля. Если нет выделенных, то –1.
* Columns: integer; - число колонок, в которых помещаются переключатели (по умолчанию равен 1).
RadioGroup потомок TwinControl – обрабатывает все события, возникающие при использовании клавиатуры и мыши. 

Событие по умолчанию OnClick. 


### Список выключателей CheckListBox.


Список независимых переключателей CheckListBox подобен панели независимых переключателей. Отдельно взятая позиция представляет собой выключатель (флажок) – компонент CheckBox. 

Он может находиться в одном из трех положений:

* включен в него помещается символ «галочка» черного цвета;
* выключен – нет галочки он пуст;
* нейтрален - в него помещается символ «галочка» серого цвета;

**Свойства:**

* Items:TString; - список названий выключателей.
* Checked\[index:integer]:Boolean; - содержит состояние выключателя с индексом Index. 
* ItemEnabled\[Index:Integer]:Boolean; - определяет доступность каждого выключателя в списке выключателей.
* AllowGrayed:Boolean; - разрешает или запрещает использовать нейтральное состояние cdGrayed.
* Flat:Boolean; - определяет имеет выключатель 3D бордюр придающий ему выступающий или утопленный вид.
* State\[index]: TcheckBoxState; - содержит состояние выключателя с заданным индексом (выкл, включ, нейтральное (cdUnchecked,cdChecked,cdGrayed)).

**Событие:**

* OnClickCheck – наступает при изменении состояния любого выключателя.

***

***

## <a name="16"></a> 16. Панель (зависимых переключателей RadioGroup).

Страница Standart. Это общий случай переключателей Radiobutton. Панель переключателей позволяет создать группу зависимых переключателей и определить какой из них нажат.
Свойства панели переключателей:

* Items:TString;-содержит список названий переключателей.
* ItemIndex:integer; - порядковый номер выделенного переключателя. Нумерация с нуля. Если нет выделенных, то –1.
* Columns: integer; - число колонок, в которых помещаются переключатели (по умолчанию равен 1).
* RadioGroup потомок TwinControl – обрабатывает все события, возникающие при использовании клавиатуры и мыши. 

Событие по умолчанию OnClick. 


***

## <a name="17"></a> 17. Список независимых выключателей CheckListBox.

Список независимых переключателей CheckListBox подобен панели независимых переключателей. Отдельно взятая позиция представляет собой выключатель (флажок) – компонент CheckBox. 

Он может находиться в одном из трех положений:

* включен в него помещается символ «галочка» черного цвета;
* выключен – нет галочки он пуст;
* нейтрален - в него помещается символ «галочка» серого цвета;

**Свойства:**

* Items:TString; - список названий выключателей.
* Checked\[index:integer]:Boolean; - содержит состояние выключателя с индексом Index. 
* ItemEnabled\[Index:Integer]:Boolean; - определяет доступность каждого выключателя в списке выключателей.
* AllowGrayed:Boolean; - разрешает или запрещает использовать нейтральное состояние cdGrayed.
* Flat:Boolean; - определяет имеет выключатель 3D бордюр придающий ему выступающий или утопленный вид.
* State\[index]: TcheckBoxState; - содержит состояние выключателя с заданным индексом (выкл, включ, нейтральное (cdUnchecked,cdChecked,cdGrayed)).

**Событие:**

* OnClickCheck – наступает при изменении состояния любого выключателя.

***

## <a name="18"></a> 18. Список ListBox. Комбинированная строка ввода ComboBox.

### Список ListBox


Страница Standart.Предназначен для непосредственного отображения списка строк на экране. Применяется его как список выбора, т.е. может быть выделена одна или несколько строк.   

**Свойства:**

* Items:TStrings; - задает элементы списка.
* MultiSelect:Boolean; - определяет разрешается ли одновременно выделять несколько элементов списка. 
* ItemIndex:Integer; - определяет индекс выделенного элемента в списке. Нумерация с нуля. Если выделенного нет, то значение минус 1. Если может быть выделено несколько элементов, указывается индекс активного. Свойство доступно только на этапе выполнения программы.
* Selected\[Index:Int]:Boolean; - если i-й элемент списка выделен, то True. Доступно только на этапе выполнения программы.
Sorted:Boolean; - должны ли строки в списке автоматически сортироваться в алфавитном порядке.

**Метод:**

* Clear  - метод удаляет все элементы списка.

**Событие:**

* OnClick - по умолчанию  - оно возникает, когда в окне ListBox выделяется один или несколько элементов



### Комбинированная строка ввода ComboBox.

ComboBox - поле со списком. Объединяет в себе возможности строки ввода Edit и списка ListBox, поэтому свойства и методы заимствованы из обоих объектов. Используя ComboBox можно вводить в список новые элементы, осуществлять поиск нужного элемента в списке, отображать активный элемент списка.

Свойства:

* Item:TStrings; - задает элементы списка.
* DroppedDown:Boolean; - отображается ли в данный момент раскрывающийся список.
* DropDownCount:Integer; - число элементов, отображаемое в раскрывающемся списке.
* ItemIndex:Integer; - определяет индекс выделенного элемента в списке. Нумерация с нуля. Если выделенного нет, то значение минус 1.
* Text:TCaption; - текст выбранной или введенной строки.

Отсутствует  свойство MultiSelect не допускается множественный выбор.
Основные операции такие же как и в ListBox. 

* OnChange - событие по умолчанию, возникает при изменении текста в окне редактирования.




***

## <a name="19"></a> 19. Создание меню. Главное меню. Контекстное меню PopupMenu.

### Создание меню.

Для создания главного меню имеется невизуальный компонент MainMenu, расположенный на странице Standart. 

Главное свойство, которого Items:TMenuItem;Default;  - содержит элементы нулевого уровня нулевого уровня главного меню
Процесс создания меню на этапе конструирования осуществляется с помощью встроенного конструктора меню (Menu  Designer). 

Для его вызова устанавливается компонент  MainMenu;
двоиной щелчок по нему, или контекстное меню  и вызватьMenu  Designer, или открыть меню Items.

### Главное меню.

Каждый элемент меню представляет собой объект класса TMenuItem, который является непосредственным потомком TComponent.элемент меню может представлять собой:
* подменю;
* команду;
* разделительную линию.

* Bitmap:TBitmap – указатель на объект, содержащий побитовое отображение изображения. Используется для связывания элемента меню и изображения.
* Caption:string; – текст элемента меню. Если перед символом поместить &, то создастся клавиша быстрого перехода (акселератор) для открытого меню. Переход осуществляется при нажатии Alt+символ.
* Cheked:Boolean; – если ИСТИНА, элемент помечается галочкой
* Count:Integer; - содержит число младших элементов, находящихся в свойстве Item. Доступно только для чтения.
* Default:Boolean; - если ИСТИНА, то текст меню выделяется полужирным , а двойное нажатие старшего элемента приводит к появлению у текущего элемента обработчика события OnCleack. По умолчанию ЛОЖЬ.
Enabled:Boolean; 
* Items\[i]:TMenuItem;default; - задает младшие по отношению к текущему элементу. Число младших задается свойством Count. Нумерация с нуля, свойство доступно для чтения.

        Type TShortCut=Low(Word)..High(Word);

* Propery ShortCut:TShortCut; - определяет комбинацию «горячих»  клавиш для быстрого выбора элемента меню.

Собыите.

* Property OnClick:TnotyfyEvent; - возникает при выборе элемента меню.

### Контекстное меню PopupMenu.

Контекстное меню может быть создано для любого оконного элемента управления. Для вызова его необходимо поместить на элементе указатель мыши и щелкнуть правой кнопкой. Конструирование контекстного меню аналогично главному меню, но необходимо установить связь с оконным элементом, для чего используется свойство PopupMenu оконного элемента (в нем указывается ссылка на компонент контекстное меню).

    Type TPopupAlignment=(paLeft,paRight,paCenter);

* Property Alignment: TpopupAlignment; - определяет положение курсора относительно мыши: слева, справа, по центру.
* Property AutoPopup:Boolean; - если ИСТИНА, то контекстное меню появляется при нажатии правой клавиши мыши. ЛОЖЬ -  следует применять метод Popup
* Procedure Popup(X,Y:Integer);virtual; - выводит на экран контекстное меню с координатами левого угла X Y.
* Property OnPopup:TNotifyEvent; - возникает при выборе элемента меню и нажатии Enter или левой кнопки мыши.

Контекстное меню создается аналогично главному с той разницей, что привязывается к одному или нескольким оконным элементам.

***

## <a name="20"></a> 20. Класс StringGrid.

Страница Additional.

Предназначена для отображения двумерной информации, например, таблицы. В таблице может быть произвольное количество строк и столбцов. Если зафиксировать необходимое количество первых строк и столбцов, то можно задать заголовки строк и столбцов, постоянно присутствующие в окне компонента, при горизонтальном и вертикальном скроллинге.

На пересечении строк и столбцов находятся ячейки, в них может содержаться символьная строка и произвольный объект, ассоциированный с ячейкой.

Если задан режим редактирования, то на этапе выполнения программы разрешен ввод и редактирования данных, находящихся в ячейке.

Нумерация начинается с нуля, координаты каждой ячейки задаются парой чисел: номер столбца, номер строки. (3,4) – 4столбец, 5 строка.

Свойства:

* Col/ Row :Longint; - столбец /строка где находится активная ячейка.
* ColCount / RowCount :Longint; - число столбцов / строк.
* ColWidths\[i] / RowHeigths\[i]:integer; - ширина и  высота i-й строки в таблице. 
* DefaultColWidths:integer; DefaultRowHeight:integer; - задает исходную ширину высоту всех строк.
* FixedColor:TColor; - цвет фиксированных ячеек. 
* FixedCols:Integer; - число фиксированных столбцов 
* FixedRows:Integer; - число фиксированных строк (1 по умолчанию).
* property Selection:TGridRect; - указывает область текущего выделения. При выделении указываются номера строк и столбцов. 

Каждая ячейка может находиться в одном из пяти состояний: пассивном, выделенном (выделена цветом), активном (выделена рамкой из точек), фиксированном (выделена особым цветом) и редактирования (значение флага goEditing равно True).  Для определения поведения таблицы используется свойство 
**Property Options**

* GoFixedVertLine GoFixedHorzLine– фиксированные ячейки разделяются вертикальными горизонтальн линиями.
* GoVertLine GoHorzLine – остальные ячейки разделяются вертикальными гоизонтальными линиями.
* GoRangeSelect – допустимо выделение нескольких ячеек.
* GoRowSizing GoColSizing– высота строк столбцов может изменяться.
* GoRowMoving GoColMoving – строки столбцы таблицы могут перемещаться.
* GoEditing – ячейки могут редактироваться.
* GoTabs – переход от ячейки к ячейке может с помощью клавиши Tab.
* GoRowSelect – вы деление только целых строк таблицы.
* GoAlwaysShowEditor – при выделении ячейки она сразу же становится активной  ( в противном случае двойным нажатием, либо любой символьной клавишей).
* GoThumbTacking – перемещение подвижной части таблицы синхронно с перемещением ползунка скроллинга, в противном случае – перемещение  происходит после отпускания клавиши.

Доступ к данным находящимся в ячейках осуществляют следующие свойства (все доступны на этапе выполнения программы).

* Cells\[Acol,Arow:integer]:string; - содержимое ячейки с заданным столбцом и строкой.
* Cols\[Index:integer]:TStrings; - список ячеек всех строк, принадлежащих столбцу с индексом Index.
* Rows\[Index:integer]:TStrings; - список ячеек всех столбцов, принадлежащих строки с индексом Index.
* Objects\[Acol,Arow:integer]: TObject;
двумерный массив, элементами которого являются указатели на объекты, каждый из которых ассоциирован на ячейку с индексами …



***

## <a name="21"></a> 21. Диалоговые окна.

Диалоговое окно — вспомогательное окно, содержащее кнопки и
другие элементы управления, при помощи которых можно выполнить ту или иную
команду или задачу.

Виды диалоговых окон:

* окна ввода информации;
* окна вывода информации (окна сообщений).

    ShowMessage(const Msg: String);

Окно сообщения с кнопкой OK. В заголовке окна название исполняемого файла, а строка Msg выводится как текст сообщения.

**Стандартные диалоговые окна.**

**MessageDlg**

    MessageDlg(const Msg:String; Atype:TmsgDlgType; Abuttons:tMsgButtons;HelpCtx: Longint) :Word;

Окно сообщения типа Atype в центре экрана и позволяет получить ответ на него. Тип окна:

* mtWarning – черный восклицательный знак в желтом треугольнике; Warning
* mtError – белый крест в красном круге заголовок Error
* mtInformation – буква I в белом круге заголовок Information
* mtConfirmation – знак вопроса заголовок Confirmation
* mtCustom – нет картинки в заголовке имя исполняемого файла

Тип кнопки Abuttons задает набор кнопок и может принимать любой набор значений : mtError mbNo  mbCancel  mbHelp  mbAbort  mbRetry  mbIgnore  mbAll
Abuttons  имеет две константы, задающие кнопки: mbYes, NoCancel и mbOkCancel. При нажатии любой из кнопок происходит закрытие окна (кроме Help), а свойство ModalResult возвращается функцией MessageDlg.

HelpCtx – определяет контекст справки.

    MessageDlgPos(const Msg: String; AType:TmsgDlgType; Abutton:TmsgDlgButtonS; HelpCtx:Longint; X,Y:integer):Word;

Отличается от функции MessageDlg наличием параметров положения окна на экране.

**InputBox**

    InputBox(const Acaption, Aprompt, Adefault: string):string;

Функция создающая диалоговое окно для ввода строки текста, возвращает строку. Окно в центре содержит поле ввода с надписью и кнопки OK Cancel. 
* Acaption, - заголовок окна
* Aprompt – поясняющий текст к полю ввода.
* Adefault – строка возвращаемая при отказе.

Например 

    InputBox(‘пользователь’,’введите фамилию’,’Иванов’);
    Procedure InputQuery(const Acaption, Aprompt, Adefault: string; var value:string):Boolean;

Возвращает результат в value. Результат True, если выход Ок, False если выход кнопкой Cancel.


***

## <a name="22"></a> 22. Форма. Характеристики формы. Создание формы. Активность формы. События формы. Управление видимостью. Получение фокуса. Перерисовка формы. Закрытие формы. Обработка событий клавиатуры. Оформление формы. Слить формы.

### Форма.

Форма – контейнер всех других компонентов.

Может быть несколько форм в приложении, но одна главная. Она отображается первой, при закрытии ее закрывается приложение. В файле .dpr главная описывается первой.

Форма может быть модальной и немодальной. Модальная, блокирует дальнейшую работу приложения (пока ее не закроешь).

Форма, которая отображает различные сообщения и требует ввода некоторой информации, называется диалоговым окном.

Обычно форма состоит из: заголовка, главного меню, клиентской части, строки состояния.

### Характеристики формы.

Форма- визуальный компонент и имеет свойства, методы и события, присущие всем визуальным компонентам, но есть и специфические.
Каждой форме соответствует один экземпляр класса Tform1 и модуль Unit1.

### Создание формы.

Файл => Новый => Форма

### Активность формы.

Свойство Active булевского типа      if form1.active then…- активна ли форма.

*  WindowState – состояние отображения формы, может принимать одно из следующих значений:
* wsNormal – обычное;
* wsMinimazed – свернута;
* wsMaximmized – развернута 

### События формы.

Форма может генерировать следующие события типа TnotyfyEvent:
OnCreate- только раз при создании формы, поэтому туда включаются действия по инициализации формы и те действия, которые делаются однократно;

* OnShow - при визуализации формы;
* OnResize – при изменении размеров;
* OnActivate – при активизации;
* OnPaint – при прорисовке.
* OnClose

### Управление видимостью.

Методы Show (Hide) – при этом свойство Visible устанавливается True (False). В момент отображения формы возникает событие OnShow в момент скрытия OnHide.

    Procedure Tform.Button1Click(Sender:Tobject);
    Begin
        Form2.Show;
    End; 

Форма может быть открыта и как модальная методом ShowModal

    Procedure Tform.Button1Click(Sender:Tobject);
    Begin
        Form2.ShowModal;
    End; 

### Получение фокуса.

При нажатии мышки в области формы происходи ее активизация, возникает событие OnActivate, а при потере фокуса OnDeactivate

### Перерисовка формы.

При активизации форма, если она была закрыта другими окнами полностью или частично возникает перерисовка формы и генерируется событие OnPaint

### Закрытие формы.

Метод Close удаляется форма с экрана, если закрывается главная форма, то закрывается приложение. Форма закрывается, но не уничтожается.

### Обработка событий клавиатуры.
Свойство keyPreview:Boolean; false по умолчанию, если True то события клавиатуры обрабатываются раньше формой, чем элементами управления. Обычно используется для обработки горячих клавиш не зависящих от элемента управления, а только от формы.

### Оформление формы. Стиль формы.

Стиль формы на этапе конструирования и выполнения определяется свойством FormStyle:

* FsNormal- стандартный;
* FsMDIChild – дочерняя форма в многодокументном приложении;
* FsStayOnTop – после запуска всегда отображается поверх других (для системной информации).

Рамка.

Свойство BorderStyle ( TformBorderStyle):

* BsDialog – диалоговая размеры не изменяются во время выполнения, но могут изменяться прораммно;
* BsSingle – с неизменяемыми размерами;
* BsNone – нет видимой рамки для заставок;
* BsSizeable – обычная с изменяемыми размерами;
* BsToolWindow - форма панели инструментов;
* bsSizeToolWin - форма панели инструментов;

***

## <a name="23"></a> 23. Рамка. Кнопки. Размещение и размер. Полосы прокрутки. Взаимодействие форм.

### Рамка.

Свойство BorderStyle ( TformBorderStyle):

* BsDialog – диалоговая размеры не изменяются во время выполнения, но могут изменяться прораммно;
* BsSingle – с неизменяемыми размерами;
* BsNone – нет видимой рамки для заставок;
* BsSizeable – обычная с изменяемыми размерами;
* BsToolWindow - форма панели инструментов;
* bsSizeToolWin - форма панели инструментов;

### Кнопки.
Набор кнопок в свойстве BorderIcons (TBorderIcons):

* biSystemMenu – имеется системное меню и кнопки;
* biMinimize – окно содержит кнопку свертывания;
* biMaximize – кнопку развертывания/восстановления;
* biHelp – кнопку справки (кнопка со знаком вопроса и контекстно-зависимой помощью)

### Размещение и размер.

Свойство Position:

* poDisigned – отбражается в той позиции и с теми размерами, что при конструировании.
* PoScreenCenter – в центре экрана размеры изменяемы;
* PoDefault – автоматически определяет начальную позицию;
* poMainFormCenter – выводится в центе экрана
* poOwnFormCenter – в центре родительского компонента.

### Полосы прокрутки.

* AutoScroll:Boolean – автоматически устанавливает полосы прокрутки.

### Взаимодействие форм.

Если одна форма выполняет какие-либо действия с другой формой, то в списке uses раздела Implementation первой формы должен быть указан модуль второй формы. Это может быть сделано программно или автоматически.

***

## <a name="24"></a> 24. Модальные формы. Диалоговые окна. Стандартные диалоговые окна. Шаблоны форм.

### Модальные формы.

Отображение формы в модальном режиме 	   

    Form2.ShowModal;

ShowModal – функция (целого типа) при закрытии модального окна возвращает значение свойства ModalResult: mrNone(=0) mrOK(=1), mrCancel(=2), mrAbort(=3), mrRetry(=4), mrIgnore(=5), mrYes(=6), mrNo(=7) 

### Диалоговые окна. 

    ShowMessage(const Msg: String);

Окно сообщения с кнопкой OK. В заголовке окна название исполняемого файла, а строка Msg выводится как текст сообщения.

### Стандартные диалоговые окна.

**MessageDlg**

    MessageDlg(const Msg:String; Atype:TmsgDlgType; Abuttons:tMsgButtons;HelpCtx: Longint) :Word;

Окно сообщения типа Atype в центре экрана и позволяет получить ответ на него. Тип окна:

* mtWarning – черный восклицательный знак в желтом треугольнике; Warning
* mtError – белый крест в красном круге заголовок Error
* mtInformation – буква I в белом круге заголовок Information
* mtConfirmation – знак вопроса заголовок Confirmation
* mtCustom – нет картинки в заголовке имя исполняемого файла

Тип кнопки Abuttons задает набор кнопок и может принимать любой набор значений : mtError mbNo  mbCancel  mbHelp  mbAbort  mbRetry  mbIgnore  mbAll
Abuttons  имеет две константы, задающие кнопки: mbYes, NoCancel и mbOkCancel. При нажатии любой из кнопок происходит закрытие окна (кроме Help), а свойство ModalResult возвращается функцией MessageDlg.

HelpCtx – определяет контекст справки.

    MessageDlgPos(const Msg: String; AType:TmsgDlgType; Abutton:TmsgDlgButtonS; HelpCtx:Longint; X,Y:integer):Word;

Отличается от функции MessageDlg наличием параметров положения окна на экране.

**InputBox**

    InputBox(const Acaption, Aprompt, Adefault: string):string;

Функция создающая диалоговое окно для ввода строки текста, возвращает строку. Окно в центре содержит поле ввода с надписью и кнопки OK Cancel. 
* Acaption, - заголовок окна
* Aprompt – поясняющий текст к полю ввода.
* Adefault – строка возвращаемая при отказе.

Например 

    InputBox(‘пользователь’,’введите фамилию’,’Иванов’);
    Procedure InputQuery(const Acaption, Aprompt, Adefault: string; var value:string):Boolean;

Возвращает результат в value. Результат True, если выход Ок, False если выход кнопкой Cancel.

### Шаблоны форм.

Хранилище объектов позволяет сохранять формы и другие объекты в качестве шаблонов для дальнейшего использования. 
В меню Файл => Новый => Другой имеются страницы:

* New – пустая новая форма Form
* Forms: 
	* AboutBox – справочное окно.
	* Dual List Box – форма с двумя списками.
	* Tabbed Pages – форма с блокнотом.

* Dialogs:
	* Dialog with Help - диалоговое окно с кнопкой Help.
	* Password Dialog – окно для ввода пароля.

***

## <a name="25"></a> 25. Приложение.

Приложение описывается классом Tapplication. Объект  автоматически создается при каждом запуске среды. На этапе конструирования объект не доступен, но его создание отражается в файле проекта .dpr.

    program Prim;
    uses
        Forms,
        im in 'im.pas' {Form1};
    {$R *.res}
    begin
        Application.Initialize;
        Application.CreateForm(TForm1, Form1);
        Application.Run;
    end.

* Title: string; Определяет название приложения и содержит текст идентифицирующий приложение. По умолчанию название совпадает с именем exe файла project1.
* ExeName:string; Содержит путь и имя исполнимого файла, доступно для чтения на этапе выполнения.
* Active:Boolean; Активно ли  приложение
* HelpFile:string; Имя справочного файла.

        Application.HelpFile:=’D:\ Help.hlp’; По умолчанию пустая строка. Если несколько файлов в справочной системе, то они активизируются по необходимости этой же командой.

* HintPause; HintHidePause; HintColor;( Hint – текст подсказки в кажд эл) 
По умолчанию подсказка появляется через 0.5с убирается через 2.5с. временные задержки задаются в свойстваx

        Application.HintPause:=100;
        Application.HintHidePause:=5000;
        Application.HintColor:=clRed;
        Application.Icon.loadFromFile(primer.ico); - задание значка.

**Методы.**

ProcessMessages 

При длительных вычислительных операциях приложение не реагирует на поступающие сообщения, в том числе и на действия пользователя. Чтобы исправить положение есть метод ProcessMessages
procedure TForm1.Button1Click(Sender: TObject);

    var i:longint;
    begin
        for i:=1 to 10000000 do
            begin
                edit1.Text:=intToStr(i);
                application.ProcessMessages;
            end;
    end;

Объект Application доступен только на этапе выполнения приложения, поэтому для облегчения кодирования обработчиков удобно использовать компонент ApplicationEvent со страницы Additional. После размещения на форме этого компонента все события и их обработчики становятся доступными на этапе конструирования.

**События.**

Наиболее часто встречающиеся события OnIdle, OnException, OnHint
OnIdle – возникает при простое приложения.
Операции, включенные в этот обработчик выполняются каждый раз когда приложение становится в режим ожидания.



***

## <a name="26"></a> 26. Работа с файловой системой. Диск. SysUtils. Каталоги. SysUtils. Файлы. DriveComboBox. DirectoryListBox. FileListBox. FilterComboBox.

### Работа с файловой системой.

Для работы с файловой системой предназначены компоненты Win3.1 fileListBox  DirectoryListBox, DriveComboBox, FilterComboBox.

Для файловых операций используются средства системных модулей System и SysUtils. System реализует средства низкого уровня – ввод/вывод, обработка строк, опер с дин памятью. SysUtils – дополняет возможности System, в нем находятся средства по работе с дисками, каталогами, файлами, исключения, строки.

### Диск.  SysUtils.

Для определения размера диска и свободного пространства	DiskSize(Drive:byte):Int64

DiskFree(Drive:byte):Int64 – возвращают размер в байтах, при ошибке –1

Drive:byte – номер диска: 0- текущий, 1-А, 2-В, 3-С и т.д. если задан номер не существующего устройства ошибка не генерится а выводится 0.

### Каталоги. SysUtils.

* GetCurrentDir: string – возвращает тек кат
* SetCurrentDir(dir:string):boolean – смена каталога.
* CreateDir(dir:string):Boolean
* RemoveDir(dir:string):Boolean – создает новый и удаляет каталог(пустой) 

### Файлы.

* FileCreate(FileName):integer – создает файл в качестве результата дискриптор
* RenameFile(Old,NewName):Boolean; - переименует
* DeleteFile(FileName):Boolean; - удаляет
* FileGetAttr(FileName):integer; - возвращает атрибуты
* FileSetAttr(FileName, attr:integer):integer; - устанавливает атрибуты.

Поиск и проверка наличия.

* FileExist(filename):Boolean – проверяет наличие
* FileSearch(Name,DirList):string – поиск по имени в каталогах
* FindFirst(path,atr,seach) - 
* FindNext(path,atr,seach) – поиск в кат path с атр 
* FindClose(,seach)

Работа с именами дисков и файлов

* ExtractFileDrive(FileName):str – возвращает имя дискового устройства.
* ExtractFilePath(FileName):str
* ExtractFileDir(FileName):str
* ExtractFileName(FileName):str
* ExtractFileExt(FileName):str

Чтение и запись из файлов

* FileOpen(FileName,Mode:int):integer; - открывает  mode – режим доступа
* FileClose(FileHandle:integer); - закрывает (дискриптор)
* FileRead(FileHandle; var Buffer,count:integer) – считывает из ф в буфер count байт
* FileWrite(FileHandle; var Buffer,count:integer)
* FileSeek(Handle,Offset,Origin:integer)- перемещения по файлу Offset – на ск позиций смещение, Origin куда смещаться 0- от начала, 1- от тек поз 2- от конца.

### DriveComboBox.

Компонент используется для выбора дисковода. Раскрывается список ComboBox со всеми установленными в системе дисковыми накопителями, выбранный накопитель записывается в свойство Drive:Char не доступное инспектору, но доступное программе, т.е. его можно установить и так DriveComboBox1.Drive:=’a’;

### DirectoryListBox.

Компонент служит для просмотра и перемещения по дереву каталогов. 
Прямоугольная область со скроллингом, в котором отображается дерево каталогов с выбранным текущим каталогом. Строка с выбранным каталогом находится в свойстве Directory  не доступном инспектору. 
DirectoryListBox1.Directory:=’a:\first’;

Отобразить выбранный каталог через свойство dirLabel автоматически отображает каталог на метке, при этом на длину строки накладывается ограничение 24 символа. 

При необходимости полного отображения всей строки можно использовать надпись Label не связанную с DirectoryListBox значение которой присвоить в обработчике события OnChange

### FileListBox.

Для просмотра списка файлов заданного каталога и выбора имени файла.

Просматриваемый каталог задается свойством Directory. Если FileListBox и DirectoryListBox связанны свойством FileList, то обновление происходит одновременно. Список файлов каталога доступен через Items. 

Для автоматического отображения выбранного файла можно использовать компонент Edit, который связать с FileListBox с помощью свойства FileEdit.

Если список поддерживает выбор нескольких файлов свойство MultiSelect должно иметь значение TRUE, а вместо однострочного редактора Edit можно использовать Memo, при этом автоматического отображения не происходит.

При выборе файла в свойство FileName заноситься его полное имя. Свойство доступно и для чтения и для записи, поэтому можно программно выбирать файл. 

### FilterComboBox.

Выбор маски для списка файлов. Компонент содержит фильтры, пользователь может выбрать. Фильтр состоит из текстового описания и маски. Свойство FileList связывает фильтр со списком.



***

## <a name="27"></a> 27. Обработка исключений. Классы исключений. Наиболее часто используемые исключения.

### Обработка исключений.

Механизм обработки ошибок инкапсулирован в классе Exception. Возникающие динамические ошибки (времени выполнения) автоматически преобразуются в средствами Делфи в объекты-исключения. Объект-исключение содержит информацию о типе ошибки и при возникновении исключения заставляет программу временно приостановиться. После обработки объекты-исключения автоматически удаляются.

### Классы исключений.

Базовым классом для всех исключений служит класс Exception, описан он в модуле SysUtils. Потомки содержат большое количество исключений, которые могут возникнуть в процессе выполнения приложения. Любые новые исключения должны быть потомками Exception, что обеспечивает возможность их распознавания и обработки как исключения. Имена потомков исключения начинаются с Е.. Класс Exception происходит от Tobject и имеет простое описание 2 свойства и 8 методов. Исключения создаются при выполнении приложения, поэтому свойства доступны также при выполнении. 

Свойства

    Message:string;

Содержит описание исключения, при возникновении исключения этот текст возникает в диалоговом окне обработчика события.

    HelpContext:ThelpContext;

Хранит уникальный номер (идентификатор контекста), указывающий на раздел контекстной помощи для объекта исключения.

Методы

    Create(const Msg:String);

Конструктор, который создает объект исключение. Msg – текст исключения.

### Наиболее часто используемые исключения.

* Eabort - Тихое исключение без вызова  глобального обработчика 
* Eout OfMemory - Нехватка оперативной памяти для выполнения операции.
* EIntOutError - Базовый класс для ошибок связанных с целочисленными вычислениями 
* EmathError - Базовый класс для обработки ошибок с плавающей запятой.
* EinvalidPointer - Некорректная операция с указателем.
* EconvertError - Ошибка преобразования типа.
* EcreateError - Ошибка создания файла.
* EopenError - Ошибка открытия файла.
* ElistError - Ошибка в списках.
* EprinterError - Ошибка печати. 





***

## <a name="28"></a> 28. Обработка исключений. Глобальная обработка. Локальная обработка. Вызов исключений.

### Обработка исключений.

Для обработки исключений в приложении есть один глобальный обработчик и несколько процедур обработчиков, реагирующих на соответствующие исключения. Каждое исключение обрабатывает свой специализированный локальный обработчик. Исключение, не имеющее локальный обработчик, обрабатывается глобальным обработчиком.
Глобальная обработка.

### Глобальная обработка.

Глобальная обработка реализуется через объект Application , который есть в любом приложении. При получении от операционной системы сообщения об исключении объект Application генерирует событие  OnException, обработчик которого является глобальным обработчиком исключений

### Локальная обработка.

Для локальной обработки в языке есть две конструкции

    Try //инструкции, выполнение которых может вызвать ошибку
    finaly // инструкции, которые выполняются даже при ошибке (освобождение памяти, закрытие файла), т.е. обработки не происходит, используется перед передачей глобальному обработчику
    end;
    try //инструкции, выполнение которых может вызвать ошибку
    except // инструкции, которые должны быть выполнены при ошибке
    end;

данная форма используется для перехвата исключения и его обработки. Работает конструкция так: если в try возникает исключение, входим в Except, иначе выполняем следующий оператор за end. Для исключений такого вида глобальный обработчик не вызывается, обработку ошибок делает сам программист.

Блок Except может быть разбит на несколько частей с помощью конструкций on…do, позволяющих анализировать класс исключения для его более удобной полной обработки

On {идентификатор: класс исключения} do
{инструкция обработки исключения этого класса} else {инструкции};

    procedure TForm1.Button1Click(Sender: TObject);
    var x,y,res:real;
    begin
    try
        x:=StrToInt(Edit1.Text);    y:=StrToInt(Edit2.Text);
        res:=x/y;
        edit3.Text:=FloatToStr(res);
    except
        on EzeroDivide do
            begin 
            messageDlg('попытка дел на нуль',mtError,[mbOk],0);
                edit2.SetFocus;   edit3.Text:='ошибка';
            end;
    end;
    end;

### Вызов исключений.

При необходимости исключение можно сгенерировать программно, для этого используется инструкция  Raise, которая создает исключение, объект класса Exeption. 

Raise ClassExeption.Method; 

ClassExeption – класс исключения, на основе которого создается исключение.
В качестве метода обычно используется Create – метод создания исключения.

Пример:

    function test(edt:string):string;
    begin
        if length(edt)>5
            then raise Exception.Create('слишком длинная строка')
            else test:=edt+'тел';
    end;
    procedure TForm1.Button1Click(Sender: TObject);
    begin
        try
            edit1.Text:=test(edit1.Text);
        except
            on EO:Exception do
                begin
                    MessageDlg(EO.Message, mtError,[mbOK],0);
                    edit1.SetFocus;
                end;  
        end; 
    end; 


***

## <a name="29"></a> 29. Технологиия программирования и основные этапы ее развития.

### Технологиия программирования.

Технология программирования (ТП)- это совокупность методов и средств используемых в процессе разработки ПО. 

ТП представляет собой набор технологических инструкций, включающих:

* описание проектируемой системы (т.е. модели, используемые на каждом этапе разработки);
* указание последовательности выполнения технологи-ческих операций;
* указание условий, при которых выполняются операции;
* описание самих операций. 

### Основные этапы ее развития.

**Первый этап - «стихийное» программирование (50-60-е годы).**

Сформулированные технологии отсутствовали, программиро-вание было искусством. 
Первые программы имели простейшую структуру. Они состоя-ли из программы на машинном языке и данных, обраба-тываемых ею. 
Рост сложности программ в машинных кодах ограничивалась способностью программиста одновременно мысленно отслеживать алгоритм и местонахождение данных при программировании.

Для повышения эффективности программирования в этот период разрабатываются ряд алгоритмических языков:

* Низкого уровня -  ассемблеры;
* Высокого уровня FORTRAN и ALGOL

Революционным было появление в языках подпрограмм, которые сохранялись и использовались в других программах. В результате были созданы огромные библиотеки расчетных и служебных подпрограмм, которые по мере надобности вызывались из разрабатываемой программы.

**Второй этап - структурный подход к программированию.**

Структурный подход (60-70-е годы) охватывает все этапы разработки ПО. Он требует представления задачи в виде иерархии («часть-целое») подзадач более простой структуры вплоть до небольших подпрограмм (40-50 операторов). Разработка осуществляется «сверху-вниз», подразумевая детализацию общей идеи. 

Поддержка принципов структурного программирования была заложена в основу процедурных языков программирования PL/1, ALGOL-68, Pascal, С,включающих «структурные» операторы, подпрограммы, локализацию данных.

Структурный подход также потребовал структурирования данных. Появляются пользовательские типы данных. Разграничивается доступ к глобальным данным программы, чтобы уменьшить количество ошибок. 

В результате появилась технология модульного программирования, предполагающая выделение групп подпрограмм, использующих одни и те же глобальные данные в модули (отдельно компилируемые библиотеки). Связи между модулями осуществляются через интерфейс, а доступ к телам подпрограмм и «внутренним» переменным запрещен.

Модульное программирование упростило разработку ПО несколькими программистами, каждый из них может разрабатывать свои модули независимо от других, взаимодействие модулей обеспечивается через специально оговоренные межмодульные интерфейсы. Кроме того, модули в дальнейшем без изменений можно было использовать в других разработках, что повысило производительность труда программистов.

Но структурный подход позволяет создавать надежные программы размером до 100.000 операторов. Причины: ошибка в интерфейсе выявляется при выполнении программы. При росте программы растает сложность межмодульных интерфейсов, и предусмотреть взаимовлияние отдельных частей программы становится практически невозможно. 
Для разработки ПО большого объема был предложен объектный подход.

**Третий этап - объектный подход к программированию (с середины 80-х до конца 90-х годов XX в.).**

Программа представляется в виде ряда объектов. 
Объекты объединяют в себе данные и подпрограммы, обрабатывающие эти данные. 

Каждый объект является экземпляром класса (типа), а классы образуют иерархию с наследованием («простое-сложное).

Взаимодействие объектов осуществляется путем передачи сообщений. 

Основным достоинством объектно-ориентированного программирования (ООП) по сравнению со структурным яв-ляется «более естественная» декомпозиция задачи, которая существенно облегчает его разработку. 

Это приводит к более полной локализации данных и интегрированию их с подпрограммами обработки, что позво-ляет вести практически независимую разработку отдельных частей (объектов) программы. 

Кроме этого, объектный подход предлагает новые способы организации программ, основанные на механизмах инкапсуляции, наследования, полиморфизма, что позволяет конструировать сложные объекты из сравнительно простых. В результате существенно увеличивается повторяемость кода.

Недостатки реализации ООП в PASCALе и С++.

* компоновка объектов, полученных разными компиляторами затруднена, что приводит к необходимости разработки ПО в рамках одного компилятора и одной ОС;
* изменение реализации одного объекта, связано с перекомпиляцией всего модуля.
Связи модулей нельзя разорвать, но можно попробовать стандартизировать их взаимодействие, на чем и основан компонентный подход к программированию.

**Четвертый этап – компонентный подход и CASE-технологии (с середины 90-х годов до нашего времени).**

Компонентный подход предполагает построение ПО из отдельных компонентов, которые взаимодействуют между собой через стандартизованные двоичные интерфейсы. 

В отличие от обычных объектов объекты-компоненты можно собрать в динамически вызываемые библиотеки или исполняемые файлы (*.dll    *.exe), распространять в двоичном виде (без исходных текстов) и использовать в любом языке, поддерживающем соответствующую технологию. 

Компонентный подход лежит в основе технологий COM (Component Object Model – компонентная модель объектов), и технологии создания распределенных приложений CORBA (Common Object Request Broker Architecture - общая архитектура с посредником обработки запросов объектов). 

Технология СОМ определяет общую парадигму взаимодействия программ любых типов: библиотек, приложений, операционной системы, т. е. позволяет одной части программного обеспечения использовать функции (службы), предоставляемые другой, независимо от того, функционируют ли эти части в пределах одного процесса, в разных процессах на одном компьютере или на разных компьютерах. 

***

## <a name="30"></a> 30. Проблемы разработки сложных программных систем.

Современное ПО сложно, потому что решает сложные задачи. Кроме того:

* сложно определить требования к создаваемому ПО, т.к разработчики ПО не являются специалистами в предметных областях, и наоборот;
* не существует средств, позволяющих детально описывать поведение сложных систем на высоком уровне;
* коллективная разработка, чем больше коллектив, тем сложнее организовать процесс работы;
* увеличение повторяемости кодов повышает производи-тельность труда, отсюда стремление к универсализации, что в конечном итоге увеличивает сложность разработки.

***

## <a name="31"></a> 31. Блочно-иерархический подход к созданию сложных систем.

Большинство сложных систем имеет иерархическую внутреннюю структуру, что позволяет рассматривать их как некоторую совокупность взаимозависимых подсистем. Внутренние связи элементов таких подсистем сильнее, чем связи между подсистемами.

На свойствах иерархических систем («целое-часть») строится блочно-иерархический подход к исследованию и созданию ПО, предполагающий сначала создавать части объектов (блоки, модули), а затем собирать из них объект. 

Процесс разбиения сложного объекта на части называется декомпозицией. Процесс декомпозиции может выполняться многократно: каждый блок, в свою очередь, декомпозируют на части, пока не получают блоки, которые сравнительно легко разработать. Этот метод разработки получил название пошаговой детализации.

Чем выше блок, тем более абстрактным должно быть его описание. Это сохраняет возможность осмысления проекта и, возможность принимать правильные решения.

Совокупность методов описаний (языков, моделей) каждого иерархического уровня называется уровнем проектирования.

Использование блочно-иерархического подхода 

* делает возможным создание сложных систем;
* упрощает проверку работоспособности системы в целом и отдельных  ее блоков; 
* обеспечивает возможность модернизации систем.


***

## <a name="32"></a> 32. Жизненный цикл и этапы разработки программного обеспечения.

Жизненным циклом (ЖЦ) ПО называют период от мо-мента появления идеи создания ПО до момента завершения его поддержки разработчиком или фирмой, выполнявшей сопровождение. 
ЖЦ состоит из ряда процессов, состав которых регла-ментируется стандартом ISO/IEC 12207: 1995.  
Процесс ЖЦ определяется как совокупность взаимо-связанных действий, преобразующих некоторые входные данные в выходные. 

По стандарту процесс разработки включает следующие действия:

* подготовительную работу – выбор модели ЖЦ, стандартов, методов и средств разработки, а также составление плана работ;
* анализ требований к системе – определение ее функциональных возможностей, пользовательских требований, требований к надежности и безопасности, требований к внешним интерфейсам и т.д.;
* проектирование архитектуры системы – определение состава необходимого оборудования, ПО;
* анализ требований к ПО – определение функциональных возможностей, среды функционирования компонентов, внешних интерфейсов, спецификаций надежности и безопасности, эргономических требований, требований к используемым данным, установке, приемке, пользовательской документации, эксплуатации и сопровождению;
* проектирование архитектуры ПО – определение структуры ПО, документирование интерфейсов его компонентов, разработку предварительной версии пользовательской документации, а также требований к тестам и плана интеграции;
* детальное проектирование ПО – подробное описание компонентов ПО и интерфейсов между ними, обновление пользовательской документации, разработка и документирование требований к тестам и плана тестирования компонентов программного обеспечения, обновление плана интеграции компонентов;
* кодирование и тестирование ПО – разработку и документирование каждого компонента, а также совокупности тестовых процедур и данных для их тестирования, тестирование компонентов, обновление пользовательской документации, обновление плана интеграции программного обеспечения;
* интеграцию ПО – сборку программных компонентов в соответствии с планом интеграции и тестирование программного обеспечения на соответствие квалификационным требованиям, представляющих собой набор критериев или условий, которые необходимо выполнить, чтобы квалифицировать программный продукт, как соответствующий своим спецификациям и готовый к использованию в заданных условиях эксплуатации;
* квалификационное тестирование ПО – тестирование ПО в присутствии заказчика для демонстрации его соответствия требованиям и готовности к эксплуатации; при этом проверяется также готовность и полнота технической и пользовательской документации
* интеграцию системы – сборку всех компонентов системы, включая ПО и оборудование;
* квалификационное тестирование системы – тестирование системы на соответствие требованиям к ней и проверка оформления и полноты документации;
* установку программного обеспечения – установку программного обеспечения на оборудовании заказчика и проверку его работоспособности;
* приемку программного обеспечения – оценку результатов квалификационного тестирования программного обеспечения и системы в целом и документирование результатов оценки совместно с заказчиком, окончательную передачу программного обеспечения заказчику.




***

## <a name="33"></a> 33. Эволюци моделей жизненого цикла программного обеспечения.

**Каскадная модель. (1970-1985 годы)**

Переход на следующую стадию осуществляется после того, как полностью будут завершены проектные операции предыдущей стадии и получены все исходные данные для следующей стадии. 

Достоинствами такой схемы являются:

* получение в конце каждой стадии законченного набора проектной документации, отвечающего требованиям полноты и согласованности;
* простота планирования процесса разработки.
Данная  схема оказалась применимой только к созданию систем, для которых в самом начале разработки удавалось точно и полно сформулировать все требования.

В целом необходимость возвратов на предыдущие стадии обусловлена следующими причинами:

* уточнение спецификации в процессе разработки может привести к необходимости пересмотра уже принятых решений;
* изменение требований заказчика непосредственно в процессе разработки;
* быстрое моральное устаревание используемых технических и программных средств.

**Модель с промежуточным контролем.**

После завершения каждого этапа, позволяется при необходимости вернуться на любой уровень и внести необходимые изменения. Опасность такой схемы связана с тем, что разработка никогда не будет завершена «лучшее - враг хорошего» . 

**Спиральная модель.**

В этой схеме ПО создается не сразу, а итерационно с использованием метода прототипирования. Появление  прототипирования привело к тому модификация ПО перестала быть «необходимым злом», а стала отдель-ным процессом.

Достоинства. Начиная с некоторой итерации продукт можно предоставлять пользователю, что позволяет:

* сократить время до появления первых версий ПО;
* заинтересовать большое количество пользователей, обеспечивая быстрое продвижение следующих версий продукта на рынке; 
* ускорить формирование и уточнение спецификаций за счет появления практики использования продукта;
* уменьшить вероятность морального устаревания системы за время разработки.

Основной проблемой использования спиральной схемы является определение моментов перехода на следующие стадии. Для ее решения обычно ограничивают сроки прохождения каждой стадии, основываясь на экспертных оценках. 



***

## <a name="34"></a> 34. Ускорение разработки программного обеспечения. Технология RAD.

**Rapid Application Development** – быстрая разработка приложений
Спиральная модель ЖЦ ПО и CASE-технологий позволили сформулировать условия, выполнение которых сокращает сроки создания программного обеспечения:

* поддержка комплексом CASE-средств, обеспечивающих автоматизацию процессов, выполняемых на всех стадиях ЖЦ (спирального, итерационного);
* гарантированное достижение целей разработки с заданным качеством и в установленное время (3-6 месяцев);
* работа группами 3-7 человек.

Процесс разбивается на следующие этапы: 

**Анализ и планирование требований** - формулируют наиболее приоритетные требования.

**Проектирование** - детально описывают подсистемы и процессы, используя CASE-средства. Определяют количество функциональных точек (ФТ - процедура, документ, форма, отчет, запрос) и создают команды разработчиков.

* менее 1 тыс. функциональных точек – 1 человек;
* от 1 до 4 тыс. функциональных точек – одна команда разработчиков;
* более 4 тыс. функциональных точек – одна команда на каждые 4 тыс. точек.

**Реализация** - выполняют итеративное построение реальной системы, для контроля привлекаются будущие пользователи. Подсистемы интегрируют в систему, выполняя параллельно тестирование. 

**Внедрение** - обучают пользователей и  переходят на новую систему.
Технология RAD хорошо зарекомендовала себя для относительно небольших проектов, разрабатываемых для конкретного заказчика. Такие системы не требуют высокого уровня планирования и жесткой дисциплины проектирования. Однако эта технология не применима для построения операционных систем или программ управления сложными объектами в реальном масштабе времени.  


***

## <a name="35"></a> 35. Тестирование и отладка.

### Тестирование.

Тестирование - этап процесса разработки ПО, позволяющий выявить ошибки, допущенные при составлении программ. Тестирование не может доказать отсутствие ошибок в ПО, но  может уменьшить их количество. 

Процесс разработки ПО предполагает три стадии тестирования:

* автономное;
* комплексное;
* системное,

каждая из которых соответствует завершению соответствующей части системы.

Принципы тестирования:

* предполагаемые результаты должны быть известны до тестирования;
* следует избегать тестирования программы автором;
* необходимо проверять действия программы на неверных данных;
* необходимо проверять программу на неожиданные побочные эффекты на неверных данных.

Формирование тестовых наборов. 

Удачным следует считать тест, который обнаруживает хотя бы одну ошибку, необходимо использовать такие наборы тестов, каждый из которых с максимальной вероятностью может обнаружить ошибку.
Трудоемкость и стоимость тестирования.

Существуют два подхода к формированию тестов: структурный и функциональный.

Структурный подход базируется на том, что известна структура и алгоритмы тестируемого ПО, («стеклянный ящик»). Тесты строят так, чтобы проверить правильность реализации заданной логики в коде программы.

Функциональный подход основывается на том, что структура ПО не известна («черный ящик»), тесты строят, опираясь на функциональные спецификации. Этот подход называют также подходом, управляемым данными, так как при его использовании тесты строят на базе различных множеств данных.

Наборы тестов, полученные в соответствии с методами этих подходов, обычно объединяют, обеспечивая всестороннее тестирование программного обеспечения.

### Отладка.

Отладка - это процесс локализации и исправления ошибок, обнаруженных при тестировании ПО.

Локализация - процесс определения того оператора программы, выполнение которого вызвало нарушение нормального вычислительного процесса. Для исправления ошибки необходимо определить ее причину, т. е. определить оператор или фрагмент, содержащие ошибку. 

Сложность отладки обусловлена:

* необходимостью знаний специфики АО и ОС, среды, ЯП, специфики различных ошибок, методик отладки; 
* дискомфортностью, так как необходимо искать собственные ошибки; 
* возможностью взаимовлияния ошибок в разных частях программы; 
* отсутствием четко сформулированные методики отладки. 

Сложность отладки обусловлена :

* необходимостью знаний специфики АО и ОС, среды, ЯП, специфики различных ошибок, методик отладки; 
* дискомфортностью, так как необходимо искать собственные ошибки; 
* возможностью взаимовлияния ошибок в разных частях программы; 
* отсутствием четко сформулированные методики отладки. 

В соответствии с этапом обработки, на котором проявляются ошибки, различают: 

* синтаксические ошибки - ошибки, фиксируемые компилятором (транслятором, интерпретатором) при выполнении синтаксического и частично семантического анализа программы (ЯПс защищенным синтаксисом и с незащищенным синтаксисом); 
* ошибки компоновки - ошибки, обнаруженные компоновщиком (редактором связей) при объединении модулей программы; 
* ошибки выполнения - ошибки, обнаруженные операционной системой, аппаратными средствами или пользователем при выполнении программы. 

Методы отладки программного обеспечения.

Отладка программы в любом случае предполагает обдумывание и логическое осмысление всей имеющейся информации об ошибке. Большинство ошибок можно обнаружить по косвенным признакам посредством тщательного анализа текстов программ и результатов тестирования. При этом используют методы: 

* ручного тестирования; 
* индукции;
* дедукции;
* обратного прослеживания.

**Метод ручного тестирования.** При обнаружении ошибки необходимо выполнить тестируемую программу вручную, используя тестовый набор, при работе с которым была обнаружена ошибка.

**Метод индукции.** Метод основан на тщательном анализе симптомов ошибки, которые могут проявляться как неверные результаты вычислений или как сообщение об ошибке. 

**Метод дедукции.** По методу дедукции вначале формируют множество причин, которые могли бы вызвать данное проявление ошибки. Затем анализируя причины, исключают те, которые противоречат имеющимся данным. Если все причины исключены, то следует выполнить дополнительное тестирование исследуемого фрагмента. В противном случае наиболее вероятную гипотезу пытаются доказать. 

**Метод обратного прослеживания.** Для небольших программ эффективно применение метода обратного прослеживания. Начинают с точки вывода неправильного результата. Для этой точки строится гипотеза о значениях основных переменных, которые могли бы привести к получению имеющегося результата.

Методы и средства получения дополнительной информации.

Для получения дополнительной информации об ошибке можно выполнить добавочные тесты или использовать специальные методы и средства: 

* отладочный вывод; 
* интегрированные средства отладки; 
* независимые отладчики. 

**Отладочный вывод.** Метод требует включения в программу дополнительного отладочного вывода в узловых точках. 

**Интегрированные средства отладки.** Большинство современных сред программирования включают средства отладки, которые обеспечивают максимально эффективную отладку. 

Они позволяют: 

* выполнять программу по шагам, причем как с заходом в подпрограммы, так и выполняя их целиком; 
* предусматривать точки останова; 
* выполнять программу до оператора, указанного курсором;  
* отображать содержимое любых переменных при пошаговом выполнении;
* отслеживать поток сообщений и т.п.

**Отладка с использованием независимых отладчиков.** При отладке программ иногда используют специальные программы – отладчики, которые позволяют выполнить любой фрагмент программы  в пошаговом режиме и проверить содержимое интересующих программиста переменных. Как правило такие отладчики позволяют отлаживать программу только в машинных командах, представленных в 16-ричном коде. 


***
