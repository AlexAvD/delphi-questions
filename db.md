### Вопросы
___

1. [](#1)
2. [](#2)
3. [](#3)
4. [](#4)
5. [](#5)
6. [](#6)
7. [](#7)
8. [](#8)
9. [](#9)
10. [](#10)
11. [](#11)
12. [](#12)
13. [](#13)
14. [Основы реляционного подхода к управлению БД.](#14)
15. [Концепция реляционной модели.](#15)
    - [Правило информации.](#16)
    - [Правило гарантированного доступа.](#17)
    - [Правило поддержки недействительных значений.](#18)
    - [Правило динамического каталога, основанного на реляционной модели.](#19)
    - [Правило исчерпывающего подъязыка данных.](#20)
    - [Правило обновления представлении.](#21)
    - [Правило добавления, обновления и удаления.](#22)
    - [Правило независимости физических данных.](#23)
    - [Правило независимости логических данных.](#24)
    - [Правило независимости условий целостности.](#25)
    - [Правило независимости распространения.](#26)
    - [Правило  единственности.](#27)
16. [Составные части реляционной модели.](#28)
17. [Структура данных реляционной модели.](#29)
18. [Свойства отношений.](#30)
19. [Схема реляционной базы данных. Связи между отношениями в базе данных.](#31)
20. [Реляционная целостность данных.](#32)
21. [Индексирование.](#33)
22. [Языки управления данными.Язык DDL.](#34)
23. [Процедурный язык DML.](#35)
24. [Непроцедурный язык DML.](#36)
25. [Языки 4GL.](#37)
26. [Реализации языка SQL.](#38)
27. [Основные понятия языка SQL.](#39)
28. [Объекты и операторы языка определения данных.](#40)
29. [Операторы языка манипулирования данными и их назначение.](#41)
30. [Нормализация таблиц. (Первая нормальная форма. Вторая нормальная форма. Третья нормальная форма. Доменно-ключевая нормальная форма. Денормализация)](#42)
31. [Ограничения целостности отношений.](#43)
    - [Семантическая целостность.](#44)
    - [Доменная целостность.](#45)
    - [Ссылочная целостность.](#46)
32. [Типы данных.](#47)
    - [Строковый (символьный)](#48)
    - [Числовой.](#49)
    - [Логический (булевский).](#50)
    - [Дата и время.](#51)
    - [Интервальный.](#52)
    - [Специальные типы данных.](#53)
    - [Пользовательские типы данных.]($54)
33. [](#1)
34. [](#1)
35. [](#1)
36. [](#1)
37. [](#1)



<a name="14"></a>

### 14. Основы реляционного подхода к управлению БД.

Системы управления реляционными базами данных являются наиболее распространенным в настоящее время. 

К числу достоинств реляционного подхода можно отнести: 

* наличие небольшого набора абстракций, которые позволяют сравнительно просто моделировать большую часть распространенных предметных областей и допускают точные формальные определения, оставаясь интуитивно понятными; 
* наличие простого и в то же время мощного математического аппарата, опирающегося главным образом на теорию множеств и математическую логику и обеспечивающего теоретический базис реляционного подхода к организации баз данных; 
* возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти.


Одним из основных преимуществ реляционной модели является ее однородность. Все данные рассматриваются как хранимые в таблицах, в которых каждая строка имеет один и тот же формат. Каждая строка в таблице представляет некоторый объект реального мира или соотношение между объектами.

#### Основные понятия реляционной модели данных

**Отношение**. Таблица - совокупность объектов реального мира, которые характеризуются общими свойствами и характеристиками (поля таблицы).\
**Заголовок отношения**. Заголовок таблицы - названия полей (столбцов) таблицы.\
**Тело отношения**.	Тело таблицы - совокупность значений для всех объектов реального мира, которая представима в виде записей таблицы (строки таблицы).\
**Схема отношения**. Строка заголовков столбцов таблицы (заголовок таблицы).\
**Атрибут отношения**. Наименование столбца таблицы (поле таблицы).\
**Кортеж отношения**. Строка таблицы (запись) - однозначное представление объекта реального мира, созданное с использованием значений полей таблицы.\
**Домен**. Множество допустимых значений атрибута.\
**Значение атрибута**. Значение поля в записи
Первичный ключ	Один или несколько атрибутов, который уникальным (единственным) образом определяет значение кортежа (значение строки таблицы).\
**Внешний ключ**. Атрибут таблицы, значения которого соответствуют значениям первичного ключа в другой связанной таблице. Внешний ключ может состоять как из одного, так и из нескольких атрибутов (составной внешний ключ). Если число атрибутов внешнего ключа меньше, чем количество атрибутов соответствующего первичного ключа, то он называется усеченным (частичным) внешним ключом.
**Степень(арность) отношения**. Количество столбцов таблицы
Мощность отношения	Количество строк таблицы (количество кортежей)
**Тип данных**. Тип значений элементов таблицы.\
**Базовое отношение**. Отношение, которое содержит один или несколько столбцов, характеризующих свойства объекта, а также первичный ключ.\
**Производное отношение**. Используется для обеспечения связей между другими таблицами, может не содержать первичного ключа; если первичный ключ задан, то он состоит из внешних ключей, которые связаны с первичными ключами базового отношения

---

<a name="15"></a>

### 15. Концепция реляционной модели.

<a name="16"></a>

#### 15.1. Правило информации.

Вся информация в базе данных должна быть представлена исключительно на логическом уровне и только одним способом - в виде значений, содержащихся в таблицах.

---

<a name="17"></a>

#### 15.2. Правило гарантированного доступа. 

Логический доступ ко всем и каждому элементу данных (атомарному значению) в реляционной базе данных должен обеспечиваться путем использования комбинации имени таблицы, первичного ключа и имени столбца.

Это правило указывает на роль первичных ключей при поиске информации в базе данных. Имя таблицы позволяет найти требуемую таблицу, имя столбца - требуемый столбец, а первичный ключ - строку, содержащую искомый элемент данных.

---

<a name="18"></a>

#### 15.3. Правило поддержки недействительных значений.

В реляционной базе данных должна быть реализована поддержка недействительных значений, которые отличаются от строки символов нулевой длины, строки пробельных символов, от нуля или любого другого числа и используются для представления отсутствующих данных независимо от типа этих данных.

Это требует, чтобы отсутствующие данные можно было представить с помощью недействительных (пустых) значений (NULL).

---

<a name="19"></a>

#### 15.4. Правило динамического каталога, основанного на реляционной модели.

Описание базы данных на логическом уровне должно быть представлено в том же виде, что и основные данные, чтобы  пользователи,  обладающие соответствующими  правами, могли работать с ним с помощью того же реляционного языка, который они применяют для работы с основными данными.

Правило гласит, что реляционная база данных должна сама себя описывать. Другими словами, база данных должна содержать набор системных таблиц, описывающих структуру самой базы данных.

---

<a name="20"></a>

#### 15.5. Концепция реляционной модели.Правило исчерпывающего подъязыка данных.

Реляционная система может поддерживать различные языки и режимы взаимодействия с пользователем (например, режим вопросов и ответов). Однако должен существовать по крайней мере один язык, операторы которого можно представить в виде строк символов в соответствии с некоторым четко определенным синтаксисом и который в полной мере поддерживает определение данных; определение представлений; обработку данных (интерактивную и программную); условия целостности; идентификацию прав доступа; границы транзакций (начало, завершение и отмена).

Правило требует, чтобы СУБД использовала язык реляционной базы данных, например SQL. Такой язык должен поддерживать все основные функции СУБД: создание базы данных, чтение и ввод данных, реализацию защиты базы данных и т. д.


---

<a name="21"></a>

#### 15.6. Правило обновления представлении. 

Все представления, которые теоретически можно обновить, должны  быть доступны для обновления.

Правило касается представлений, которые являются виртульными таблицами,  позволяющими показывать различным пользователям различные фрагменты структуры базы данных. Это одно из правил, которое сложнее всего реализовать на практике.

---

<a name="22"></a>

#### 15.7. Правило добавления, обновления  и удаления.

Возможность работать с отношением как с одним операндом должна существовать не только при чтении данных, но и при добавлении, обновлении и удалении данных.

Правило акцентирует внимание на том, что базы данных по своей природе ориентированы на множества. Оно требует, чтобы операции добавления, удаления и обновления можно было выполнять над множествами строк. Это правило предназначено для того, чтобы запретить реализации, в которых поддерживаются только операции над одной строкой.

---

<a name="23"></a>

#### 15.8. Правило независимости физических данных.

Прикладные программы и утилиты для работы с данными должны на логическом уровне оставаться нетронутыми при любых изменениях способов хранения данных или методов доступа к ним.

Правила означает отделение пользователя и прикладной программы от низкоуровневой реализации базы данных. Правило утверждает, что конкретные способы реализации хранения или доступа, используемые в СУБД, и даже изменения структуры таблиц базы данных не должны влиять на возможность пользователя работать с данными.

---

<a name="24"></a>

#### 15.9. Правило независимости логических данных.

Прикладные программы и утилиты для работы с данными должны на логическом уровне оставаться  нетронутыми  при  внесении в базовые таблицы  любых   изменений,   которые  теоретически   позволяют сохранить нетронутыми содержащиеся в этих таблицах данные

Правила означает отделение пользователя и прикладной программы от низкоуровневой реализации базы данных. Правило утверждает, что конкретные способы реализации хранения или доступа, используемые в СУБД, и даже изменения структуры таблиц базы данных не должны влиять на возможность пользователя работать с данными.

---

<a name="25"></a>

#### 15.10. Правило независимости условий целостности.

Должна существовать возможность определять условия целостности, специфические   для   конкретной   реляционной   базы   данных,   в подъязыке реляционной базы данных и хранить их в каталоге, а не в прикладной программе.

Правило гласит, что язык базы данных должен поддерживать ограничительные условия, налагаемые на вводимые данные и действия, которые могут быть выполнены над данными.

---

<a name="26"></a>

#### 15.11. Правило независимости распространения.

Реляционная СУБД не должна зависеть от потребностей конкретного клиента.

Правило гласит, что язык базы данных должен обеспечивать возможность работы с распределенными данными, расположенными на других компьютерных системах.


---

<a name="27"></a>

#### 15.12. Правило единственности.  

Если   в   реляционной  системе есть   низкоуровневый   язык   (обрабатывающий   одну  запись один раз), то должна отсутствовать возможность использования: его для того, чтобы обойти правила и условия целостности, выраженные на реляционном языке высокого уровня (обрабатывающем несколько записей за один раз).

Правило предотвращает использование других возможностей для работы с базой данных помимо языка базы данных, поскольку это может нарушить ее целостность.

---

<a name="28"></a>

### 16. Составные части реляционной модели.

Согласно трактовки Кристофера Дейта в реляционной модели выделяются следующие составные части:

* структурная; 
* целостностная; 
* манипуляционная.

В структурной части модели определяется, что единственной структурой данных, используемой в реляционных БД, является нормализованное n-арное отношение. 

В целостной части реляционной модели данных фиксируются два базовых требования целостности, которые должны поддерживаться в любой реляционной СУБД.

* правила целостности сущностей (отношений); 
* правила ссылочной целостности.

В манипуляционной части модели утверждаются два фундаментальных механизма манипулирования реляционными БД - реляционная алгебра и реляционное исчисление. Первый механизм базируется в основном на классической теории множеств, а второй - на классическом логическом аппарате исчисления предикатов первого порядка

---

<a name="29"></a>

### 17. Структура данных реляционной модели.

Структура данных предполагает представление предметной области рассматриваемой задачи в виде набора взаимосвязанных отношений. При создании информационной системы совокупность отношений позволяет хранить данные об объектах предметной области и моделировать связи между ними. В каждой связи одно отношение может выступать как основное (базовое), а другое отношение выступает в роли подчиненного (производного). Таким образом, один кортеж основного отношения может быть связан с несколькими кортежами подчиненного отношения. Для поддержки этих связей оба отношения должны содержать наборы атрибутов, по которым они связаны. В основном отношении это первичный ключ отношения, который однозначно определяет кортеж основного отношения. В подчиненном отношении для моделирования связи должен присутствовать набор атрибутов, соответствующий первичному ключу основного отношения. Однако здесь этот набор атрибутов уже является вторичным ключом или внешним ключом, т. е. он определяет множество кортежей отношения, которые связаны с единственным кортежем основного отношения. Множество взаимосвязанных друг с другом таблиц образуют схему базы данных.

---

<a name="30"></a>

### 18.	Свойства отношений.

Свойства отношений непосредственно следуют из приведенного ранее определения отношения. В этих свойствах в основном и состоят различия между отношениями реляционной модели данных и простыми таблицами.

* Уникальность имени отношения. Имя одного отношения должно отличаться от имен других отношений.
* Уникальность кортежей. В отношении нет одинаковых кортежей. Действительно, тело отношения есть множество кортежей и, как всякое множество, не может содержать неразличимые элементы. Таблицы в отличие от отношений могут содержать одинаковые строки. Каждая ячейка отношения содержит только атомарное (неделимое) значение.
* Неупорядоченность кортежей. Кортежи не упорядочены (сверху вниз), т. к. тело отношения есть множество, а множество не упорядочено (для сравнения - строки в таблицах упорядочены). Одно и то же отношение может быть изображено разными таблицами, в которых строки идут в различном порядке.
* Неупорядоченность атрибутов. Атрибуты не упорядочены (слева направо).
* Уникальность имени атрибута в пределах отношения. Каждый атрибут имеет уникальное имя в пределах отношения, значит, порядок атрибутов не имеет значения (для сравнения - столбцы в таблице упорядочены). Это свойство несколько отличает отношение от математического определения отношения. Одно и то же отношение может быть изображено разными таблицами, в которых столбцы идут в различном порядке.
* Атомарность значений атрибутов. Все значения атрибутов атомарны. Это следует из того, что лежащие в их основе атрибуты имеют атомарные значения, т. е. с каждым атрибутом связана какая-то область значений (отдельный элементарный тип), значения атрибутов берутся из одного и того же домена. Схема и кортежи отношения- множества, а не списки, поэтому порядок их представления не имеет значения. Для сравнения в ячейки таблицы можно поместить различную информацию: массивы, структуры, другие таблицы и т. д.

Следует отметить, что реляционная модель представляет собой базу данных в виде множества взаимосвязанных отношений, которые называются   схемой реляционной базы данных.

---

<a name="31"></a>

### 19. Схема реляционной базы данных.Связи между отношениями в базе данных.

Связи, которые можно выделить между отношениями в базе данных, классифицируются по следующим типам.

* "Один-к-одному" - означает, что каждая запись первой таблицы может соответствовать неболее одной записи во второй таблицы, а каждой записи во второй таблицы не более одной записи в первой таблицы.
* "Один-ко-многим" - означает, что каждая запись первой таблицы может соответствовать несколько записям второй таблицы. Однако каждая запись второй таблицы может соответствовать не более одной записи.
* "Многие-ко-многим" - означает, что каждой записи таблице могут соответствовать несколько записей второй таблицы. Наличие такого отношения говорит об ошибке в проектировании базы данных.

---

<a name="32"></a>

### 20. Реляционная целостность данных.

Для поддержки целостности данных необходимо:

* Связующее поле в главной таблице должно быть ключевым или иметь уникальное значение;
* Связующее поле обоих таблиц должно иметь одинаковый тип данных;
* Обе таблицы должны относиться к одной БД.

При поддержке целостности данных на операции с данными накладываются следующие ограничения:

* В связующее поле подчиненной таблицы можем ввести только не значения, которые имеются в поле главной таблице;
* Мы не можем удалить запись из главной таблицы, если с ней связаны одна или несколько записей подчиненных таблиц.

---

<a name="33"></a>

### 21.	Индексирование.

Индекс представляет собой средство ускорения поиска записей в таблице, а также других операций, использующих поиск: извлечение, модификацию, сортировку и т. д. Таблицу, для которой используют индекс, называют индексированной.

Индекс содержит отсортированную по колонке или нескольким колонкам информацию и указывает на строки, в которых хранится конкретное значение колонки. Индекс выполняет роль оглавления таблиц, просмотр которого предшествует обращению к записям таблицы. В некоторых системах индексы хранятся в индексных файлах отдельно от табличных.
Решение проблемы организации физического доступа к ин-формации зависит в основном от следующих факторов:

* вида содержимого в поле ключа записей индексного файла;
* типа используемых ссылок (указателей) на запись основной таблицы;
* метода поиска нужных записей.

Некоторые СУБД поддерживают кластеризацию, кластеризованные хешированные индексы.

Кластеризация - помещение в один блок записей таблиц, которые с большой вероятностью будут часто подвергаться соединению.

Кластеризованный индекс - специальная техника индексирования, при которой данные в таблице физически располагаются в индексированном порядке. Использование кластеризованного индекса значительно ускоряет выполнение запросов по индексированной колонке. Для каждой таблицы может существовать только один кластеризованный индекс. При создании кластеризованного индекса не по первичному ключу автоматически снимается кластеризация по первичному ключу.

Хеширование - альтернативный способ хранения данных в заранее заданном порядке с целью ускорения поиска (прямой доступ). Хеширование избавляет от необходимости поддерживать и просматривать индексы. Кластеризованный хешироваииый индекс значительно ускоряет операции поиска и сортировки, но добавление и удаление строк замедляется из-за необходимости реорганизации данных для соответствия индексу. Хеширование применяется в том случае, когда необходим прямой доступ (без индексов), например при бронировании авиабилетов, мест в гостиницах, прокате машин, а также электронных денежных переводах. Однако недостатком хеширования являются необходимость нахождения соответствующей хеш-функции, необходимость выполнения операции свертки (требует определенного времени), возможные коллизии  (свертка различных значений  может дать  одинаковый хеш-код) и промежутки между записями неопределенной протяженности. При хешировании RID-указатель вычисляется с помощью некоторой хеш-функции и называется хеш-кодом В поле ключа индексного файла  можно  хранить значения ключевых полей индексируемой таблицы либо свертку ключа (хеш-код). Длина хеш-кода всегда постоянна и имеет достаточно малую величину (например, 4 байта), а это существенно снижает время поисковых операций.

Общим недостатком индексных схем является необходимость хранения индексов, к которым требуется обращаться для обнаружения записей.

---

<a name="34"></a>

### 22. Языки управления данными. Язык DDL.

Язык DDL. Описательный язык, который позволяет администратору БД или пользователю описать и именовать сущности и атрибуты, необходимые для работы некоторого приложения, а также связи, имеющиеся между различными сущностями, кроме того, указать ограничения целостности и защиты.

Схема базы данных состоит из набора определений, выраженных на спец альном языке определения данных - DDL. Язык DDL используется как для определения новой схемы, так и для модификации уже существующей. Этот язык нельзя использовать для управления данными. Результатом компиляции DDL-операторов является набор таблиц, хранимый в особых файлах, называемых системным каталогом. В системном каталоге интегрированы метаданные - т.е. данные, которые описывают объекты базы данных, а также позволяют упростить способ доступа к ним и управления ими. Метаданные включают определения записей, элементов данных, а также другие объекты, представляющие интерес для пользователей или необходимые для работы СУБД. Перед доступом к реальным данным СУБД обычно обращается к системному каталогу. Для обозначения системного каталога также используются термины словарь данных и каталог данных, хотя первый из них (словарь данных) обычно относится к программному обеспечению более общего типа, чем просто каталог СУБД.
    
---

<a name="35"></a>

### 23. Процедурный язык DML. 

Язык, который позволяет сообщить системе о том, какие данные необходимы, и точно указать, как их можно извлечь.

С помощью процедурного языка DML пользователь, а точнее - программист, указывает на то, какие данные ему необходимы и как их можно получить. Это значит, что пользователь должен определить все операции доступа к данным (осуществляемые посредством вызова соответствующих процедур), которые должны быть выполнены для получения требуемой информации. Обычно такой процедурный язык DML позволяет извлечь запись, обработать ее и, в зависимости от полученных результатов, извлечь другую запись, которая должна быть подвергнута аналогичной обработке, и т.д. Подобный процесс извлечения данных продолжается до тех пор, пока не будут извлечены все запрашиваемые данные. Обычно операторы процедурного языка DML встраиваются в программу на языке программирования высокого уровня, которая содержит конструкции для обеспечения циклической обработки и перехода к другим участкам кода. Языки DML сетевых и иерархических СУБД обычно являются процедурными.

---

<a name="36"></a>

### 24. Непроцедурный язык DML.

Непроцедурный язык DML. Язык, который позволяет указать лишь то, какие данные требуются, но не то, как их следует извлекать.

Непроцедурные языки DML позволяют определить весь набор требуемых данных с помощью одного оператора выборки или обновления. С помощью непроцедурных языков DML пользователь указывает, какие данные ему нужны, без определения способа их получения. СУБД транслирует выражение на языке DML процедуру (или набор процедур), которая обеспечивает манипулирование затребованным набором записей. Такой подход освобождает пользователя от необхо-димости знать подробности внутренней реализации структур данных и особенности алгоритмов, используемых для извлечения и возможного преобразования данных. В результате работа пользователя становится в определенной степени независимой от данных. Непроцедурные языки часто также называют декларативными языками. 


---

<a name="37"></a>

### 25.	Языки 4GL.

Аббревиатура 4GL представляет собой сокращенный английский вариант на писания   термина   язык   четвертого   поколения   (Fourth Generation Language). Четкого определения этого понятия не существует, хотя, по сути, речь идет некотором стенографическом варианте языка программирования. Если для организации некоторой операции с данными на языке третьего поколения (3GL),  потребуется написать сотни строк кода, то для реализации этой же операции на языке четвертого поколения достаточно 10-20 строк, в то время как языки третьего поколения являются процедурными, языки 4GL  выступают как непроцедурные, поскольку пользователь определяет, что должно быть сделано, но не сообщает, как именно должен быть достигнут желаемый результат.  Пользователю не требуется определять все этапы выполнения программы, необходимые для решения поставленной задачи, а достаточно лишь задать нужные параметры, на основании которых упомянутые выше инструменты автоматически осуществят генерацию приложения. Языки четвертого поколения позволят повысить производительность работы на порядок, но за счет ограничения типов задач, которые можно будет решать с их помощью.

Выделяют следующие типы языков четвертого поколения:

* языки представления информации, например языки запросов или генераоры 
отчетов;
* специализированные языки,  например языки  электронных  таблиц и  баз данных;
* генераторы приложений,  которые при создании приложений обеспечивают определение, вставку, обновление или извлечение сведений из базы данных;
* языки очень высокого уровня, предназначенные для генерации кода приложений.

---

<a name="38"></a>

### 26. Реализации языка SQL.

В техническом смысле SQL является «подъязыком данных», который предназначен только для использования в качестве взаимодействия с базой данных. Сам по себе SQL не содержит тех средств, которые необходимы для разработки законченных программ, и может использоваться в виде одной из трех прикладных реализаций:

* Интерактивный или автономный SQL дает возможность пользователям непосредственно извлекать информацию из базы данных или записывать ее в базу.
* Статический SQL – фиксированный (исполняемый), записанный заранее, а не генерируемый во время выполнения программы код SQL. Существует две версии статического SQL. Встроенный SQL – это код SQL, включенный в код исходного текста программы, написанной на другом языке. Другое использование статического SQL – модульный язык. В этом случае модули SQL скомпонованы с модулями кода других языков.
* Динамический SQL – код SQL, сгенерированный приложением во время исполнения. Он заменяет статический SQL в тех случаях, когда необходимый код SQL еще не может быть определен во время написания приложения, так как сам код зависит от того, какой выбор сделает пользователь (во время реализации приложения). Операторы динамического SQL часто генерируются такими средствами разработки, как, например, графические языки запросов (реализующие запросы пользователя).

---

<a name="39"></a>

### 27.	Основные понятия языка SQL.

SQL отличается от языков программирования высокого уровня несколькими признаками. Во-первых, он относится к непроцедурным языкам. На языке типа COBOL или С можно записать для компьютера шаг за шагом все инструкции, необходимые для исполнения задания. SQL просто декларирует, что нужно делать, а исполнение возлагает на СУБД. Такой подход лежит в русле философии реляционных баз данных. СУБД в данном случае рассматривается как «черный ящик»: что делается внутри него – пользователя не касается. Его интересует только получение правильного ответа из базы данных и внесение в нее необходимых изменений. Ограничивая пользователя в вопросах исполнения операторов, SQL позволяет упростить сами операции и обеспечивает гибкость при реализации баз данных.

Другим важным преимуществом SQL является трехзначная логика (3VL). В большинстве языков используются булевы выражения, которые могут принимать только два значения: TRUE (истина) и FALSE (ложь). Язык SQL позволяет записывать в базу данных значение NULL (неопределенное значение). NULL является маркером, используемым для заполнения пространства в столбце, где по какой либо причине отсутствуют данные. (Значение может быть неприменимо, как, например, цвет волос в отношении птицы; может отсутствовать, как, например, цвет волос у лысого человека; и может быть неизвестным, как, например, цвет волос у человека в маске). Результатом применения арифметических операторов к NULL и другому значению, содержащему NULL, должно быть значение NULL. Когда значение NULL используется при сравнении, булево значение результата сравнения будет ни TRUE и ни FALSE, а UNKNOWN. 

Традиционно операторы SQL были разбиты на категории в соответствии с их функциями. Ниже приведены три категории, традиционно использующихся при обсуждении вопросов, связанных с базами данных:

* Язык определения данных (Data Definition Language – DDL) включает в себя все операторы, используемые для определения схем и объектов внутри схем. Наиболее важные операторы DDL применяются для создания различных объектов, например, операторы CREATE SCHEMA, CREATE TABLE, CREATE VIEW, CREATE ASSERTION и CREATE DOMAIN.
* Язык манипулирования данными (Data Manipulation Language – DML) включает все операторы, которые используются для записи, изменения и поиска данных в таблицах. Основные операторы этого языка: SELECT, INSERT, UPDATE и DELETE. Оператор SELECT применяется для формирования запросов, и, возможно, является наиболее сложным из одиночных операторов SQL. Остальные операторы используются для манипулирования данными в рамках таблиц.
* Операторы управления данными (Data Control Statements). Эта группа содержит операторы, которые используются для того, чтобы определить, что могут и чего не могут делать пользователи с объектами базы данных. Основными операторами этой категории являются GRANT и REVOKE (отмена).


---

<a name="40"></a>

### 28. Объекты и операторы языка определения данных.

Язык определения данных (Data Definition Language – DDL) включает в себя все операторы, используемые для определения схем и объектов внутри схем. Наиболее важные операторы DDL применяются для создания различных объектов, например, операторы CREATE SCHEMA, CREATE TABLE, CREATE VIEW, CREATE ASSERTION и CREATE DOMAIN.

---

<a name="41"></a>

### 29. Операторы языка манипулирования данными и их назначение.

Язык манипулирования данными (Data Manipulation Language – DML) включает все операторы, которые используются для записи, изменения и поиска данных в таблицах. Основные операторы этого языка: SELECT, INSERT, UPDATE и DELETE. Оператор SELECT применяется для формирования запросов, и, возможно, является наиболее сложным из одиночных операторов SQL. Остальные операторы используются для манипулирования данными в рамках таблиц.

---

<a name="42"></a>

### 30. Нормализация таблиц. (Первая нормальная форма. Вторая нормальная форма. Третья нормальная форма. Доменно-ключевая нормальная форма. Денормализация)

#### Первая нормальная форма.

Любая таблица, удовлетворяющая определению отношения, находится в 1НФ. 

Вот основные характеристики таблицы в 1НФ: 

* В каждой строке таблицы должны содержаться данные, соответствующие некоторому объекту или его части; 
* В каждом столбце должны находиться данные, соответствующие одному из атрибутов отношения; 
* В каждой ячейке таблицы должно находиться только единственное значение; 
* У каждого столбца должно быть уникальное имя; 
* Все строки (записи) в таблице должны быть различными; 
* Порядок расположения столбцов и строк в таблице не имеет значения. 

Таблица (отношение) в 1НФ свободна от некоторых аномалий, но все же подвержена многим другим. Например, таблица1 находится в 1НФ, но, как уже было отмечено, подвержена аномалиям удаления и добавления записей. 

#### Вторая нормальная форма.

Каждая таблица в 1НФ должна иметь первичный ключ. Он может состоять из одного или более столбцов (атрибутов). В последнем случае ключ называется составным. Чтобы таблица была в 2НФ, все ее не ключевые столбцы должны однозначно определяться всем ключом, т. е. всеми его компонентами, а не некоторыми из них.

Рассмотрим пример отношения. Таблица: Секции.

| Имя     | Секция   | Оплата |
| ------- | -------- | ------ |
| Иванов  | Футбол   | 100    |
| Иванов  | Волейбол | 120    |
| Петров  | Лыжи     | 170    |
| Сидоров | Шахматы  | 200    |
| Сидоров | Лыжи     | 170    |
| Фёдоров | Лыжи     | 170    |
| Фёдоров | Волейбол | 120    |

Ключом в данном отношении является {имя, Секция}, но оно содержит функциональную зависимость секция - плата. Аргумент. (левая часть) этой зависимости является лишь частью составного ключа. Отношение секции имеет аномалии удаления и добавления. Так, если мы захотим удалить записи с именем "иванов", то потеряем стоимость футбольной секции. Мы не сможем добавить запись о новой секции, пока в нее кто-нибудь не запишется. Данных аномалий можно было бы избежать, если бы атрибут плата зависел от всего ключа (однозначно определялся всем ключом). 

Отношение секции (Имя, Секция, Плата) в 1НФ можно разбить на два отношения во 2НФ: 

* Секция_члены (Имя, Секция); 
* Секция_плата (Секция, Плата). 

#### Третья нормальная форма.

В отношениях могут быть так называемые транзитивные зависимости, являющиеся источником аномалий модификации данных, против которых 2НФ бессильна. Транзитивная зависимость имеет место тогда, когда один атрибут однозначно определяет второй, второй однозначно определяет третий и т. д. 

Рассмотрим в качестве примера отношение гости (ID_гостя, тип_номера, плата), представляющее сведения о проживающих в гостинице. Ключом в этом отношении является ID_гостя, плата однозначно определяется атрибутом тип номера (например, люкс, полулюкс и т. д.), т. е. имеется функциональная зависимость тип номера - > плата. Поскольку каждый гость проживает только в одном номере определенного типа, в отношении есть и функциональная зависимость ID_гостя - >тип_номера. Таким образом, возникает транзитивная (опосредованная) зависимость  ID_гостя-> плата. Так как ключ состоит из единственного атрибута ID_гостя, то отношение находится в 2НФ. 

В рассматриваемом отношении существует аномалия удаления. Удалив запись, мы потеряем не только информацию о каком-то госте (где он проживает), но и сведения о том, сколько стоит номер соответствующего типа. 

Чтобы устранить указанную аномалию, следует декомпозировать 
исходное отношение гости (ID_гостя, Тип_номера, плата) на два: 

* Проживание (ID_гостя, Тип_номера); 
* Тип плата (Тип_номера, Плата). 

Эти отношения будут находиться в 2НФ и не содержать транзитивных зависимостей. 

Таким образом, отношение находится в 3НФ, если оно находится в 2НФ и не содержит транзитивных зависимостей. 

#### Доменно-ключевая нормальная форма.

Если таблица находится в ЗНФ, то остается довольно мало шансов для возникновения аномалий модификации данных, но они все равно есть. Чтобы исключить все виды возможных аномалий, таблица должна находиться в доменно-ключевой нормальной форме (ДКНФ). 

Понятие ДКНФ довольно просто: отношение находится в ДКНФ, если каждое ограничение, накладываемое на него, является логическим следствием определения доменов и ключей. Термин ограничение (constraint) здесь намеренно трактуется широко. Р. Фагин определяет ограничение как любое правило, регулирующее возможные статические значения атрибутов, достаточно точное, чтобы можно было проверить его выполнимость. Правила редактирования, ограничения взаимосвязей и структуры отношений, функциональные и многозначные зависимости являются примерами таких ограничений. Отсюда исключаются ограничения, связанные с изменением данных (ограничения, зависящие от времени). Другими словами, отношение находится в ДКНФ, если выполнение ограничений на домены и ключи влечет за собой выполнение всех ограничений. 

Однако в настоящее время не известен алгоритм преобразования отношения в ДКНФ. Неизвестно также, какие отношения в принципе могут быть приведены к ДКНФ. Поиск и создание отношений в ДКНФ сейчас является искусством, а не наукой. В литературе обычно приводятся только примеры отношений в ДКНФ, которые мы здесь рассматривать не будем. 

#### Денормализация 

Чтобы исключить как можно больше аномалий модификации данных, старайтесь как можно больше нормализовать таблицы базы данных. Лучше, если вы доведете их до ДКНФ, хотя на практике это редко происходит. Чаще ограничиваются второй или третьей нормальными формами. Занимаясь нормализацией, вы увеличиваете количество таблиц в базе данных, и при определенном их количестве эффективность работы может оказаться слишком низкой. Кроме того, формулировать SQL-запросы к базе данных тем легче, чем меньше в ней таблиц. Так что на любом этапе своего развития база данных может быть в какой-то степени денормализованной. 

---

<a name="43"></a>

### 31. Ограничения целостности отношений.

<a name="44"></a>

#### 31.1. Семантическая целостность.

<a name="45"></a>

#### 31.2. Доменная целостность.

<a name="46"></a>

#### 31.3. Ссылочная целостность.

---

<a name="47"></a>

### 32. Типы данных.

<a name="48"></a>

#### 32.1. Строковый (символьный).

Строковые данные (последовательности символов) имеют три главных строковых типа. Для столбца таблицы можно указать тип **CHARACTER(n)** или **CHAR(n)** (строка фиксированной длины), где n - максимальное количество символов, содержащихся в строке. Если (n) не указано, то предполагается, что строка состоит из одного символа. Если в столбец типа **CHARACTER(n)** вводится m< n символов, то оставшиеся позиции заполняются пробелами. 

Тип данных **CHARACTER VARYING(n)** или **VARCHAR(n)** (строка переменной длины) применяется тогда, когда вводимые данные имеют различную длину и нежелательно дополнять их пробелами. При этом сохраняется только то количество символов, которое ввел пользователь. В данном случае указание максимального количества символов обязательно (в отличие от CHARACTER). 

Данные типов **CHARACTER** и **CHARACTER VARYING** могут участвовать в одних и тех же строковых операциях. 
Тип данных **CHARACTER LARGE OBJECT** (**CLOB** - большой символьный объект) используется для представления очень больших символьных строк (например, статей, книг и т. п.). В некоторых СУБД данный тип называется MEMO, а в других - text. С данными этого типа можно выполнять не все операции, предусмотренные для типов **CHARACTER** и **CHARACTER VARYING**. Так, их нельзя использовать в операциях сравнения, за исключением равенства и неравенства. Кроме того, столбцы этого типа не могут быть первичными и внешними ключами, а также быть объявлены как имеющие уникальные значения. Иначе говоря, при создании таблиц с помощью оператора **CREATE** и объявлении столбцов типа CLOB нельзя использовать ключевые слова **PRIMARY KEY**, **FOREIGN KEY** и **UNIQUE**. 

В следующем примере создается таблица с обычным символьным столбцом и столбцом типа CLOB, значения которого могут содержать 100 000 символов: 

    CREATE TABLE myTable ( 
        FIELD1 CHARACTER(60), 
        FIELD2 CLOB (100000) 
    ); 

Здесь оператор **CREATE TABLE** создает таблицу с именем myTable,.' -'. которая состоит из двух столбцов с именами FIELD1 и FIELD2, типы столбцов указаны рядом с их именами. 

Различные языки используют различные наборы символов. Даже английский и немецкий наборы отличаются, не говоря уж о русском и китайском. Система может быть настроена на некоторый набор символов, принимаемый по умолчанию. Однако при этом можно использовать и другие национальные символьные наборы. Так, в следующем примере создается таблица, в которой столбец FIELD1 объявляется как строковый с набором символов, принятым по умолчанию, а столбец FIELD 2 - как строковый с греческим набором символов: 

    CREATE TABLE myTable ( 
        FIELD1 CHARACTER (60), 
        FIELD2 CHARACTER VARYING (80) CHARACTER SET GRЕК 
    );

Значения строкового типа в SQL-выражениях заключаются в одинарные кавычки. Например, 

    'иванов иван иванович', ‘12345 рублей’, ‘тел -.(812) 123-456 '. 

Пустая строка не содержит ни одного символа и имеет вид: ''. Строка, содержащая один или более пробелов, не является пустой. 

Иногда бывает так, что строковый столбец в таблице содержит только числа (точнее, строки, содержащие цифры, знаки числа и разделительные точки). Чтобы использовать такие данные в операциях с числами, необходимо привести данные одного типа к другому типу с помощью функции **CAST()**. 

Значения типа **CHARACTER** и **CHARACTER VARYING (VARCHAR)** совместимы в том смысле, что они могут участвовать как операнды в строковых операциях и операциях сравнения.

<a name="49"></a>

#### 32.2. Числовой.

Числовой тип данных может быть двух видов - точный и приблизительный. Точные числовые типы позволяют точно выразить значение числа. Некоторые величины имеют очень большой диапазон значений, и в таких случаях достаточно ограничиться некоторым приближенным их представлением с учетом технических возможностей компьютера (размеров регистра). 

К точным числовым относятся следующие пять типов: 

* **INTEGER** - целое (без дробной части) число. Количество разрядов (точность) зависит от реализации SQL. В некоторых реализациях числа этого типа лежат в диапазоне от - 2 147 483 648 до 2 147 483 647 (четырехбайтное целое число); 
* **SMALLINT** - малое целое число. Количество разрядов зависит от реализации SQL, но не больше количества разрядов INTEGER в этой же реализации. В некоторых реализациях числа этого типа лежат в диапазоне от -32768 до 32767 (двухбайтное целое число); 
* **BIGINT** - большое целое число. Количество разрядов зависит от реализации SQL и превышает количество разрядов числа типа INTEGER. 
* **NUMERIC(x, у)** - число, в котором всего х разрядов (точность), из которых у разрядов (масштаб) отводится для дробной части. Если y не указано (NUMERIC(x)), то для дробной части отводится количество разрядов, установленное в системе по умолчанию. Если не указаны ни х, ни у (NUMERIC), то принимаются обе эти величины, установленные по умолчанию. Например, если указан тип NUMERIC(6, 2), то максимальное значение числа равно 9999. 99; 
* **DECIMAL(x, у)** - десятичное число, в котором всего х разрядов, из которых у разрядов отводятся для дробной части. Если х или/и.у не указаны, то принимаются значения по умолчанию. Этот тип очень похож на NUMERIC. Отличие состоит в том, что если в DECIMAL(x, у)  указанные х и у меньше, чем допустимые реализацией SQL, то будут использоваться последние. Если х и у не указаны, то применяется система умолчаний. Например, вы задали для столбца тип DECIMAL(6, 2). Если реализация SQL позволяет, то в этот столбец можно ввести числа, превышающие 9999. 99. В отличие от DECIMAL(x, у), тип NUMERIC(x, у) жестко задает диапазон возможных значений числовой величины. 

К приблизительным числовым типам относятся следующие три типа: 

* **REAL** - вещественное число одинарной точности с плавающей разделительной точкой (эта точка "плавает", появляясь в различных местах числа). Например, 5.25, 5.257, 5.2573. Точность представления числа зависит от реализации SQL и оборудования. Например, 32-битовый компьютер дает большую точность, чем 16-битовый; 
* **DOUBLE PRECISION** - вещественное число двойной точности с плавающей разделительной точкой. Точность представления числа зависит от реализации SQL и оборудования. Применяется для представления научных данных (например, результатов измерений) в широком диапазоне значений, т. е. как очень малых (близких к 0), так и очень больших; 
* **FLOAT(x)** - вещественное число с плавающей разделительной точкой и минимальной точностью х, занимающее не более 8 байтов. Если компьютер может поддержать указанную точность, используя аппаратную одинарную точность, то система будет использовать арифметику одинарной точности. Если указанная точность требует арифметики с двойной точностью, то система будет использовать ее. Данный тип следует применять, если предполагается возможность переноса базы данных на другую аппаратную платформу, отличающуюся размерами регистров. Пример значения типа FLOAТ: 5.318Е-24 (т. е. 5.318, умноженное на 10 в степени -24). Такую же форму представления имеют и числа типа REAL И DOUBLE PRECISION. 

<a name="50"></a>

#### 32.3. Логический (булевский).

Данные логического типа получаются в результате операций сравнения. Например, результатом вычисления выражения 3 < 5 является ИСТИНА, а выражения 2 + 3 = 10 - ЛОЖЬ. 

В SQL тип данных BOOLEAN (булевский) имеет три значения- true, false и unknown. Значение unknown (неизвестное) было введено для обозначения результата, получающегося при сравнении со значением NULL (неопределенное). Если пользователь еще не ввел в ячейку таблицы никакого значения, то эта "пустая" ячейка содержит значение NULL, интерпретируемое как неизвестное или неопределенное значение. 

Результатом любой операции сравнения true или false с NULL, или с unknown всегда является unknown. 
В SQL-выражениях логические значения заключаются в кавычки, например, 'TRUE' или 'true'. 

<a name="51"></a>

#### 32.4. Дата и время.

Тип **DATA (дата)** предназначен для хранения значений даты, элементы которых расположены в следующем порядке: год (4 цифры), дефис (-), месяц (2 цифры), дефис, день (2 цифры). Таким образом, значения даты занимают 10 позиций, например, 

    2005-10-02. 

Данные этого типа могут содержать любую дату с 0001 года по 9999 год.\
Для представления времени предусмотрены два типа: 

**TIME WITHOUT TIME ZONE** (время без часового пояса) предназначено для хранения значений времени, элементы которых расположены в следующем порядке: часы, двоеточие, минуты, двоеточие, секунды. Часы и минуты представляются двумя цифрами, а секунды могут быть представлены двумя и более цифрами (если требуется дробная часть), например 

    18:35:19.547. 

Длина дробной части секунд зависит от реализации, но внутреннее представление времени должно иметь не менее 6 цифр. По умолчанию время данного типа представляют без дробной части секунд. Чтобы указать, что время должно быть представлено с n цифрами после разделительной точки, достаточно использовать такой синтаксис: **TIME WITHOUT TIME ZONE(n)**. Например, чтобы кроме секунд указывались еще и миллисекунды, следует определить тип как TIME WITHOUT TIME ZONE (3) Длина, данных рассматриваемого типа без дробной части равна 8 символам, а с дробной частью - 9 плюс количество цифр после разделительной точки. Для задания времени без указания часового пояса с использованием установок по умолчанию можно использовать короткий синтаксис - **TIME**; 

**TIME WITH TIME ZONE** (время с часовым поясом) - такой же тип данных, как и **TIME WITHOUT TIME ZONE**. Отличие заключается лишь в том, что к значению времени добавляется еще и информация о разности между местным и всемирным временем. Всемирное время (Universal Time Coordinated, UTC) - это время по Гринвичу, т. е. время нулевого меридиана, проходящего через г. Гринвич в Великобритании (Greenwich Меап Nime, GMT). Значение разности между локальным и всемирным временем находится в диапазоне от -12:59 до 13:00. Длина данных рассматриваемого типа равна длине данных типа TIME WITHOUT TIME ZONE плюс 6, поскольку дополнительная информация о разности времен занимает 6 позиций (дефис, знак (+) или (-), 2 цифры для часов, двоеточие, 2 цифры для минут). 

Для одновременного представления даты и времени служат следующие два типа: 

**TIMESTAMP WITHOUT TIME ZONE** (дата и время без часового пояса). Элементы данных этого типа имеют такие же характеристики, как и для данных типа DATE И TIME WITHOUT TINE ZONE, за исключением одного: данные типа TIMESTAMP WITHOUT. 

**TIME ZONE** по умолчанию имеют 6 цифр в дробной части секунд, а не 0, как в типе **ТIME WITHOUT TIME ZONE**. Для указания количества цифр в дробной части используется синтаксис **TIMESTAMP WITHOUT TIME ZONE (n)**. Если дробной части нет, то данные занимают 19 позиций: 10 позиций для даты, один пробел и 8 позиций для времени. Если определена дробная часть, то длина данных равна 20 плюс количество цифр в дробной части секунд; 

**TIMESTAMP WITH TIME ZONE** (дата и время с часовым поясом) - такой же тип данных, как и **ТIME WITHOUT TIME ZONE**. Отличие состоит в том, что к значению времени добавляется еще и информация о разности между местным и все- мирным временем. Дополнительная информация занимает 6 позиций. Данные типа TIMESTAMP WITH TIME ZONE без дробной части занимают 25 позиций, с дробной частью - 26 плюс количество цифр в дробной части секунд. 

Чтобы представить в SQL-выражении дату, время или дату- время, необходимо использовать функцию CAST() приведения к заданному типу. Допустим, в таблице продажи имеется столбец дата типа DATA. Чтобы получить сведения из этой таблицы за период после 2005-09-30, следует выполнить такой запрос: 

    SELECT * 
    FROM продажи 
    WHERE Дата > CAST('2005-09-30' AS DATE); 
    
Здесь строка, содержащая дату, приводится к типу DATA, и полученный результат участвует в операции сравнения с данными столбца Дата. 

В языке SQL имеются три функции, которые возвращают текущие дату и время: 

* **CURRENT DATE** - возвращает текущую дату (тип DATE). На- 
пример, 2005-06-18; 
* **CURRENT_TIME(число)** - возвращает текущее время (тип TIME). Целочисленный параметр число указывает точность представления секунд. Например, при число = 2 секунды будут представлены с точностью до сотых (две цифры в дробной части): 12:39:45.27; 
* **CURRENT_TIMESTAMP(число)** - возвращает дату и время (тип TIMESТАМР), например 2005-06-18 12:39:45.27. Целочисленный параметр число указывает точность представления секунд.

<a name="52"></a>

#### 32.5. Интервалы.

Интервал представляет собой разность между двумя значениями типа дата-время. SQL поддерживает два типа интервалов: год- месяц и день-время. Интервал типа год-месяц - это количество лет и месяцев между двумя датами, а интервал день-время - количество дней, часов, минут и секунд между двумя моментами в пределах одного месяца. Нельзя смешивать вычисления, использующие интервал год-день, с вычислениями, в которых используется интервал день-время. 
Интервал времени можно задать двумя способами: в виде начального и конечного моментов или в виде начального момента и длительности, например: 

    (TIME '12:25:30', TIME '14:30:00') - интервал, заданный начальным и конечным моментами; 
    (TIME '12:45:00', INTERVAL '5' HOUR) - интервал, заданный начальным моментом и длительностью в часах. 

Чтобы задать значение типа интервал, используется такой синтаксис: 

    INTERVAL 'длина' YEAR | MONTH | DAY | HOUR | MINUTE | SECOND 

Здесь длина - длина интервала, после которой указывается единица измерения (возможные значения указаны через вертикальную черту): 

* YEAR - год; 
* MONTH - месяц; 
* DAY - день; 
* HOUR - час; 
* MINUTE - минута; 
* SECOND - секунда. 

Например, для задания интервала длиной 15 дней следует использовать выражение INTERVAL '15' DAY. 

#### 32.6. Специальные типы данных.

---