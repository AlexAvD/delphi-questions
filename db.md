<a name="0"></a>

### Вопросы

1. [](#1)
2. [](#2)
3. [](#3)
4. [](#4)
5. [](#5)
6. [](#6)
7. [](#7)
8. [](#8)
9. [](#9)
10. [](#10)
11. [](#11)
12. [](#12)
13. [](#13)
14. [Основы реляционного подхода к управлению БД.](#14)
15. [Концепция реляционной модели.](#15)
    - [Правило информации.](#16)
    - [Правило гарантированного доступа.](#17)
    - [Правило поддержки недействительных значений.](#18)
    - [Правило динамического каталога, основанного на реляционной модели.](#19)
    - [Правило исчерпывающего подъязыка данных.](#20)
    - [Правило обновления представлении.](#21)
    - [Правило добавления, обновления и удаления.](#22)
    - [Правило независимости физических данных.](#23)
    - [Правило независимости логических данных.](#24)
    - [Правило независимости условий целостности.](#25)
    - [Правило независимости распространения.](#26)
    - [Правило  единственности.](#27)
16. [Составные части реляционной модели.](#28)
17. [Структура данных реляционной модели.](#29)
18. [Свойства отношений.](#30)
19. [Схема реляционной базы данных. Связи между отношениями в базе данных.](#31)
20. [Реляционная целостность данных.](#32)
21. [Индексирование.](#33)
22. [Языки управления данными.Язык DDL.](#34)
23. [Процедурный язык DML.](#35)
24. [Непроцедурный язык DML.](#36)
25. [Языки 4GL.](#37)
26. [Реализации языка SQL.](#38)
27. [Основные понятия языка SQL.](#39)
28. [Объекты и операторы языка определения данных.](#40)
29. [Операторы языка манипулирования данными и их назначение.](#41)
30. [Нормализация таблиц.](#42)
    - [Первая нормальная форма.](#42.1)
    - [Вторая нормальная форма.](#42.2)
    - [Третья нормальная форма.](#42.3)
    - [Доменно-ключевая нормальная форма.](#42.4)
    - [Денормализация.](#42.5)
31. [Ограничения целостности отношений.](#43)
    - [Семантическая целостность.](#44)
    - [Доменная целостность.](#45)
    - [Ссылочная целостность.](#46)
32. [Типы данных.](#47)
    - [Строковый (символьный)](#48)
    - [Числовой.](#49)
    - [Логический (булевский).](#50)
    - [Дата и время.](#51)
    - [Интервальный.](#52)
    - [Специальные типы данных.](#53)
    - [Пользовательские типы данных.]($54)
33. [Преобразование типов.](#55)
34. [SQL-выражение для выборки данных.](#56)
35. [Оператор WHERE.](#57)
36. [Предикаты сравнения.](#58)
37. [BETWEEN.](#59)
38. [IN, NOT IN.](#60)
39. [LIKE, NOT LIKE.](#61)
40. [IS NULL.](#62)
41. [ALL, SOME, ANY.](#63)
42. [EXISTS.](#64)
43. [UNIQUE.](#65)
44. [DISTINCT.](#66)
45. [OVERLAPS.](#67)
46. [MATCH.](#68)
47. [SIMILAR.](#69)
48. [Оператор GROUP ВУ.](#70)
49. [Оператор HAVING.](#71)
50. [Оператор ORDER ВУ.](#72)
51. [Логические операторы.](#73)
52. [Итоговые функции.](#74)
53. [Функции обработки значений.](#75)
    - [Строковые функции.](#76)
    - [Числовые функции.](#77)
    - [Функции даты-времени.](#78)
54. [Вычисляемые выражения.](#79)
55. [Условные выражения с оператором САSЕ.](#80)
    - [Оператор САSЕ со значениями.](#81)
    - [Оператор САSЕ с условиями поиска.](#82)
    - [Функции NULLIF и COALESCE.](#83)

---

<a name="14"></a> [⇪⇪⇪](#0)

### 14. Основы реляционного подхода к управлению БД.

Системы управления реляционными базами данных являются наиболее распространенным в настоящее время. 

К числу достоинств реляционного подхода можно отнести: 

* наличие небольшого набора абстракций, которые позволяют сравнительно просто моделировать большую часть распространенных предметных областей и допускают точные формальные определения, оставаясь интуитивно понятными; 
* наличие простого и в то же время мощного математического аппарата, опирающегося главным образом на теорию множеств и математическую логику и обеспечивающего теоретический базис реляционного подхода к организации баз данных; 
* возможность ненавигационного манипулирования данными без необходимости знания конкретной физической организации баз данных во внешней памяти.


Одним из основных преимуществ реляционной модели является ее однородность. Все данные рассматриваются как хранимые в таблицах, в которых каждая строка имеет один и тот же формат. Каждая строка в таблице представляет некоторый объект реального мира или соотношение между объектами.

#### Основные понятия реляционной модели данных

**Отношение**. Таблица - совокупность объектов реального мира, которые характеризуются общими свойствами и характеристиками (поля таблицы).\
**Заголовок отношения**. Заголовок таблицы - названия полей (столбцов) таблицы.\
**Тело отношения**.	Тело таблицы - совокупность значений для всех объектов реального мира, которая представима в виде записей таблицы (строки таблицы).\
**Схема отношения**. Строка заголовков столбцов таблицы (заголовок таблицы).\
**Атрибут отношения**. Наименование столбца таблицы (поле таблицы).\
**Кортеж отношения**. Строка таблицы (запись) - однозначное представление объекта реального мира, созданное с использованием значений полей таблицы.\
**Домен**. Множество допустимых значений атрибута.\
**Значение атрибута**. Значение поля в записи
Первичный ключ	Один или несколько атрибутов, который уникальным (единственным) образом определяет значение кортежа (значение строки таблицы).\
**Внешний ключ**. Атрибут таблицы, значения которого соответствуют значениям первичного ключа в другой связанной таблице. Внешний ключ может состоять как из одного, так и из нескольких атрибутов (составной внешний ключ). Если число атрибутов внешнего ключа меньше, чем количество атрибутов соответствующего первичного ключа, то он называется усеченным (частичным) внешним ключом.\
**Степень(арность) отношения**. Количество столбцов таблицы
Мощность отношения	Количество строк таблицы (количество кортежей)\
**Тип данных**. Тип значений элементов таблицы.\
**Базовое отношение**. Отношение, которое содержит один или несколько столбцов, характеризующих свойства объекта, а также первичный ключ.\
**Производное отношение**. Используется для обеспечения связей между другими таблицами, может не содержать первичного ключа; если первичный ключ задан, то он состоит из внешних ключей, которые связаны с первичными ключами базового отношения

---

<a name="15"></a> [⇪⇪⇪](#0)

### 15. Концепция реляционной модели.

<a name="16"></a> [⇪⇪⇪](#0)

#### 15.1. Правило информации.

Вся информация в базе данных должна быть представлена исключительно на логическом уровне и только одним способом - в виде значений, содержащихся в таблицах.

---

<a name="17"></a> [⇪⇪⇪](#0)

#### 15.2. Правило гарантированного доступа. 

Логический доступ ко всем и каждому элементу данных (атомарному значению) в реляционной базе данных должен обеспечиваться путем использования комбинации имени таблицы, первичного ключа и имени столбца.

Это правило указывает на роль первичных ключей при поиске информации в базе данных. Имя таблицы позволяет найти требуемую таблицу, имя столбца - требуемый столбец, а первичный ключ - строку, содержащую искомый элемент данных.

---

<a name="18"></a> [⇪⇪⇪](#0)

#### 15.3. Правило поддержки недействительных значений.

В реляционной базе данных должна быть реализована поддержка недействительных значений, которые отличаются от строки символов нулевой длины, строки пробельных символов, от нуля или любого другого числа и используются для представления отсутствующих данных независимо от типа этих данных.

Это требует, чтобы отсутствующие данные можно было представить с помощью недействительных (пустых) значений (NULL).

---

<a name="19"></a> [⇪⇪⇪](#0)

#### 15.4. Правило динамического каталога, основанного на реляционной модели.

Описание базы данных на логическом уровне должно быть представлено в том же виде, что и основные данные, чтобы  пользователи,  обладающие соответствующими  правами, могли работать с ним с помощью того же реляционного языка, который они применяют для работы с основными данными.

Правило гласит, что реляционная база данных должна сама себя описывать. Другими словами, база данных должна содержать набор системных таблиц, описывающих структуру самой базы данных.

---

<a name="20"></a> [⇪⇪⇪](#0)

#### 15.5. Концепция реляционной модели.Правило исчерпывающего подъязыка данных.

Реляционная система может поддерживать различные языки и режимы взаимодействия с пользователем (например, режим вопросов и ответов). Однако должен существовать по крайней мере один язык, операторы которого можно представить в виде строк символов в соответствии с некоторым четко определенным синтаксисом и который в полной мере поддерживает определение данных; определение представлений; обработку данных (интерактивную и программную); условия целостности; идентификацию прав доступа; границы транзакций (начало, завершение и отмена).

Правило требует, чтобы СУБД использовала язык реляционной базы данных, например SQL. Такой язык должен поддерживать все основные функции СУБД: создание базы данных, чтение и ввод данных, реализацию защиты базы данных и т. д.


---

<a name="21"></a> [⇪⇪⇪](#0)

#### 15.6. Правило обновления представлении. 

Все представления, которые теоретически можно обновить, должны  быть доступны для обновления.

Правило касается представлений, которые являются виртульными таблицами,  позволяющими показывать различным пользователям различные фрагменты структуры базы данных. Это одно из правил, которое сложнее всего реализовать на практике.

---

<a name="22"></a> [⇪⇪⇪](#0)

#### 15.7. Правило добавления, обновления  и удаления.

Возможность работать с отношением как с одним операндом должна существовать не только при чтении данных, но и при добавлении, обновлении и удалении данных.

Правило акцентирует внимание на том, что базы данных по своей природе ориентированы на множества. Оно требует, чтобы операции добавления, удаления и обновления можно было выполнять над множествами строк. Это правило предназначено для того, чтобы запретить реализации, в которых поддерживаются только операции над одной строкой.

---

<a name="23"></a> [⇪⇪⇪](#0)

#### 15.8. Правило независимости физических данных.

Прикладные программы и утилиты для работы с данными должны на логическом уровне оставаться нетронутыми при любых изменениях способов хранения данных или методов доступа к ним.

Правила означает отделение пользователя и прикладной программы от низкоуровневой реализации базы данных. Правило утверждает, что конкретные способы реализации хранения или доступа, используемые в СУБД, и даже изменения структуры таблиц базы данных не должны влиять на возможность пользователя работать с данными.

---

<a name="24"></a> [⇪⇪⇪](#0)

#### 15.9. Правило независимости логических данных.

Прикладные программы и утилиты для работы с данными должны на логическом уровне оставаться  нетронутыми  при  внесении в базовые таблицы  любых   изменений,   которые  теоретически   позволяют сохранить нетронутыми содержащиеся в этих таблицах данные

Правила означает отделение пользователя и прикладной программы от низкоуровневой реализации базы данных. Правило утверждает, что конкретные способы реализации хранения или доступа, используемые в СУБД, и даже изменения структуры таблиц базы данных не должны влиять на возможность пользователя работать с данными.

---

<a name="25"></a> [⇪⇪⇪](#0)

#### 15.10. Правило независимости условий целостности.

Должна существовать возможность определять условия целостности, специфические   для   конкретной   реляционной   базы   данных,   в подъязыке реляционной базы данных и хранить их в каталоге, а не в прикладной программе.

Правило гласит, что язык базы данных должен поддерживать ограничительные условия, налагаемые на вводимые данные и действия, которые могут быть выполнены над данными.

---

<a name="26"></a> [⇪⇪⇪](#0)

#### 15.11. Правило независимости распространения.

Реляционная СУБД не должна зависеть от потребностей конкретного клиента.

Правило гласит, что язык базы данных должен обеспечивать возможность работы с распределенными данными, расположенными на других компьютерных системах.


---

<a name="27"></a> [⇪⇪⇪](#0)

#### 15.12. Правило единственности.  

Если   в   реляционной  системе есть   низкоуровневый   язык   (обрабатывающий   одну  запись один раз), то должна отсутствовать возможность использования: его для того, чтобы обойти правила и условия целостности, выраженные на реляционном языке высокого уровня (обрабатывающем несколько записей за один раз).

Правило предотвращает использование других возможностей для работы с базой данных помимо языка базы данных, поскольку это может нарушить ее целостность.

---

<a name="28"></a> [⇪⇪⇪](#0)

### 16. Составные части реляционной модели.

Согласно трактовки Кристофера Дейта в реляционной модели выделяются следующие составные части:

* структурная; 
* целостностная; 
* манипуляционная.

В структурной части модели определяется, что единственной структурой данных, используемой в реляционных БД, является нормализованное n-арное отношение. 

В целостной части реляционной модели данных фиксируются два базовых требования целостности, которые должны поддерживаться в любой реляционной СУБД.

* правила целостности сущностей (отношений); 
* правила ссылочной целостности.

В манипуляционной части модели утверждаются два фундаментальных механизма манипулирования реляционными БД - реляционная алгебра и реляционное исчисление. Первый механизм базируется в основном на классической теории множеств, а второй - на классическом логическом аппарате исчисления предикатов первого порядка

---

<a name="29"></a> [⇪⇪⇪](#0)

### 17. Структура данных реляционной модели.

Структура данных предполагает представление предметной области рассматриваемой задачи в виде набора взаимосвязанных отношений. При создании информационной системы совокупность отношений позволяет хранить данные об объектах предметной области и моделировать связи между ними. В каждой связи одно отношение может выступать как основное (базовое), а другое отношение выступает в роли подчиненного (производного). Таким образом, один кортеж основного отношения может быть связан с несколькими кортежами подчиненного отношения. Для поддержки этих связей оба отношения должны содержать наборы атрибутов, по которым они связаны. В основном отношении это первичный ключ отношения, который однозначно определяет кортеж основного отношения. В подчиненном отношении для моделирования связи должен присутствовать набор атрибутов, соответствующий первичному ключу основного отношения. Однако здесь этот набор атрибутов уже является вторичным ключом или внешним ключом, т. е. он определяет множество кортежей отношения, которые связаны с единственным кортежем основного отношения. Множество взаимосвязанных друг с другом таблиц образуют схему базы данных.

---

<a name="30"></a> [⇪⇪⇪](#0)

### 18.	Свойства отношений.

Свойства отношений непосредственно следуют из приведенного ранее определения отношения. В этих свойствах в основном и состоят различия между отношениями реляционной модели данных и простыми таблицами.

* Уникальность имени отношения. Имя одного отношения должно отличаться от имен других отношений.
* Уникальность кортежей. В отношении нет одинаковых кортежей. Действительно, тело отношения есть множество кортежей и, как всякое множество, не может содержать неразличимые элементы. Таблицы в отличие от отношений могут содержать одинаковые строки. Каждая ячейка отношения содержит только атомарное (неделимое) значение.
* Неупорядоченность кортежей. Кортежи не упорядочены (сверху вниз), т. к. тело отношения есть множество, а множество не упорядочено (для сравнения - строки в таблицах упорядочены). Одно и то же отношение может быть изображено разными таблицами, в которых строки идут в различном порядке.
* Неупорядоченность атрибутов. Атрибуты не упорядочены (слева направо).
* Уникальность имени атрибута в пределах отношения. Каждый атрибут имеет уникальное имя в пределах отношения, значит, порядок атрибутов не имеет значения (для сравнения - столбцы в таблице упорядочены). Это свойство несколько отличает отношение от математического определения отношения. Одно и то же отношение может быть изображено разными таблицами, в которых столбцы идут в различном порядке.
* Атомарность значений атрибутов. Все значения атрибутов атомарны. Это следует из того, что лежащие в их основе атрибуты имеют атомарные значения, т. е. с каждым атрибутом связана какая-то область значений (отдельный элементарный тип), значения атрибутов берутся из одного и того же домена. Схема и кортежи отношения- множества, а не списки, поэтому порядок их представления не имеет значения. Для сравнения в ячейки таблицы можно поместить различную информацию: массивы, структуры, другие таблицы и т. д.

Следует отметить, что реляционная модель представляет собой базу данных в виде множества взаимосвязанных отношений, которые называются   схемой реляционной базы данных.

---

<a name="31"></a> [⇪⇪⇪](#0)

### 19. Схема реляционной базы данных.Связи между отношениями в базе данных.

Связи, которые можно выделить между отношениями в базе данных, классифицируются по следующим типам.

* "Один-к-одному" - означает, что каждая запись первой таблицы может соответствовать неболее одной записи во второй таблицы, а каждой записи во второй таблицы не более одной записи в первой таблицы.
* "Один-ко-многим" - означает, что каждая запись первой таблицы может соответствовать несколько записям второй таблицы. Однако каждая запись второй таблицы может соответствовать не более одной записи.
* "Многие-ко-многим" - означает, что каждой записи таблице могут соответствовать несколько записей второй таблицы. Наличие такого отношения говорит об ошибке в проектировании базы данных.

---

<a name="32"></a> [⇪⇪⇪](#0)

### 20. Реляционная целостность данных.

Для поддержки целостности данных необходимо:

* Связующее поле в главной таблице должно быть ключевым или иметь уникальное значение;
* Связующее поле обоих таблиц должно иметь одинаковый тип данных;
* Обе таблицы должны относиться к одной БД.

При поддержке целостности данных на операции с данными накладываются следующие ограничения:

* В связующее поле подчиненной таблицы можем ввести только не значения, которые имеются в поле главной таблице;
* Мы не можем удалить запись из главной таблицы, если с ней связаны одна или несколько записей подчиненных таблиц.

---

<a name="33"></a> [⇪⇪⇪](#0)

### 21.	Индексирование.

Индекс представляет собой средство ускорения поиска записей в таблице, а также других операций, использующих поиск: извлечение, модификацию, сортировку и т. д. Таблицу, для которой используют индекс, называют индексированной.

Индекс содержит отсортированную по колонке или нескольким колонкам информацию и указывает на строки, в которых хранится конкретное значение колонки. Индекс выполняет роль оглавления таблиц, просмотр которого предшествует обращению к записям таблицы. В некоторых системах индексы хранятся в индексных файлах отдельно от табличных.
Решение проблемы организации физического доступа к ин-формации зависит в основном от следующих факторов:

* вида содержимого в поле ключа записей индексного файла;
* типа используемых ссылок (указателей) на запись основной таблицы;
* метода поиска нужных записей.

Некоторые СУБД поддерживают кластеризацию, кластеризованные хешированные индексы.

Кластеризация - помещение в один блок записей таблиц, которые с большой вероятностью будут часто подвергаться соединению.

Кластеризованный индекс - специальная техника индексирования, при которой данные в таблице физически располагаются в индексированном порядке. Использование кластеризованного индекса значительно ускоряет выполнение запросов по индексированной колонке. Для каждой таблицы может существовать только один кластеризованный индекс. При создании кластеризованного индекса не по первичному ключу автоматически снимается кластеризация по первичному ключу.

Хеширование - альтернативный способ хранения данных в заранее заданном порядке с целью ускорения поиска (прямой доступ). Хеширование избавляет от необходимости поддерживать и просматривать индексы. Кластеризованный хешироваииый индекс значительно ускоряет операции поиска и сортировки, но добавление и удаление строк замедляется из-за необходимости реорганизации данных для соответствия индексу. Хеширование применяется в том случае, когда необходим прямой доступ (без индексов), например при бронировании авиабилетов, мест в гостиницах, прокате машин, а также электронных денежных переводах. Однако недостатком хеширования являются необходимость нахождения соответствующей хеш-функции, необходимость выполнения операции свертки (требует определенного времени), возможные коллизии  (свертка различных значений  может дать  одинаковый хеш-код) и промежутки между записями неопределенной протяженности. При хешировании RID-указатель вычисляется с помощью некоторой хеш-функции и называется хеш-кодом В поле ключа индексного файла  можно  хранить значения ключевых полей индексируемой таблицы либо свертку ключа (хеш-код). Длина хеш-кода всегда постоянна и имеет достаточно малую величину (например, 4 байта), а это существенно снижает время поисковых операций.

Общим недостатком индексных схем является необходимость хранения индексов, к которым требуется обращаться для обнаружения записей.

---

<a name="34"></a> [⇪⇪⇪](#0)

### 22. Языки управления данными. Язык DDL.

Язык DDL. Описательный язык, который позволяет администратору БД или пользователю описать и именовать сущности и атрибуты, необходимые для работы некоторого приложения, а также связи, имеющиеся между различными сущностями, кроме того, указать ограничения целостности и защиты.

Схема базы данных состоит из набора определений, выраженных на спец альном языке определения данных - DDL. Язык DDL используется как для определения новой схемы, так и для модификации уже существующей. Этот язык нельзя использовать для управления данными. Результатом компиляции DDL-операторов является набор таблиц, хранимый в особых файлах, называемых системным каталогом. В системном каталоге интегрированы метаданные - т.е. данные, которые описывают объекты базы данных, а также позволяют упростить способ доступа к ним и управления ими. Метаданные включают определения записей, элементов данных, а также другие объекты, представляющие интерес для пользователей или необходимые для работы СУБД. Перед доступом к реальным данным СУБД обычно обращается к системному каталогу. Для обозначения системного каталога также используются термины словарь данных и каталог данных, хотя первый из них (словарь данных) обычно относится к программному обеспечению более общего типа, чем просто каталог СУБД.
    
---

<a name="35"></a> [⇪⇪⇪](#0)

### 23. Процедурный язык DML. 

Язык, который позволяет сообщить системе о том, какие данные необходимы, и точно указать, как их можно извлечь.

С помощью процедурного языка DML пользователь, а точнее - программист, указывает на то, какие данные ему необходимы и как их можно получить. Это значит, что пользователь должен определить все операции доступа к данным (осуществляемые посредством вызова соответствующих процедур), которые должны быть выполнены для получения требуемой информации. Обычно такой процедурный язык DML позволяет извлечь запись, обработать ее и, в зависимости от полученных результатов, извлечь другую запись, которая должна быть подвергнута аналогичной обработке, и т.д. Подобный процесс извлечения данных продолжается до тех пор, пока не будут извлечены все запрашиваемые данные. Обычно операторы процедурного языка DML встраиваются в программу на языке программирования высокого уровня, которая содержит конструкции для обеспечения циклической обработки и перехода к другим участкам кода. Языки DML сетевых и иерархических СУБД обычно являются процедурными.

---

<a name="36"></a> [⇪⇪⇪](#0)

### 24. Непроцедурный язык DML.

Непроцедурный язык DML. Язык, который позволяет указать лишь то, какие данные требуются, но не то, как их следует извлекать.

Непроцедурные языки DML позволяют определить весь набор требуемых данных с помощью одного оператора выборки или обновления. С помощью непроцедурных языков DML пользователь указывает, какие данные ему нужны, без определения способа их получения. СУБД транслирует выражение на языке DML процедуру (или набор процедур), которая обеспечивает манипулирование затребованным набором записей. Такой подход освобождает пользователя от необхо-димости знать подробности внутренней реализации структур данных и особенности алгоритмов, используемых для извлечения и возможного преобразования данных. В результате работа пользователя становится в определенной степени независимой от данных. Непроцедурные языки часто также называют декларативными языками. 


---

<a name="37"></a> [⇪⇪⇪](#0)

### 25.	Языки 4GL.

Аббревиатура 4GL представляет собой сокращенный английский вариант на писания   термина   язык   четвертого   поколения   (Fourth Generation Language). Четкого определения этого понятия не существует, хотя, по сути, речь идет некотором стенографическом варианте языка программирования. Если для организации некоторой операции с данными на языке третьего поколения (3GL),  потребуется написать сотни строк кода, то для реализации этой же операции на языке четвертого поколения достаточно 10-20 строк, в то время как языки третьего поколения являются процедурными, языки 4GL  выступают как непроцедурные, поскольку пользователь определяет, что должно быть сделано, но не сообщает, как именно должен быть достигнут желаемый результат.  Пользователю не требуется определять все этапы выполнения программы, необходимые для решения поставленной задачи, а достаточно лишь задать нужные параметры, на основании которых упомянутые выше инструменты автоматически осуществят генерацию приложения. Языки четвертого поколения позволят повысить производительность работы на порядок, но за счет ограничения типов задач, которые можно будет решать с их помощью.

Выделяют следующие типы языков четвертого поколения:

* языки представления информации, например языки запросов или генераоры 
отчетов;
* специализированные языки,  например языки  электронных  таблиц и  баз данных;
* генераторы приложений,  которые при создании приложений обеспечивают определение, вставку, обновление или извлечение сведений из базы данных;
* языки очень высокого уровня, предназначенные для генерации кода приложений.

---

<a name="38"></a> [⇪⇪⇪](#0)

### 26. Реализации языка SQL.

В техническом смысле SQL является «подъязыком данных», который предназначен только для использования в качестве взаимодействия с базой данных. Сам по себе SQL не содержит тех средств, которые необходимы для разработки законченных программ, и может использоваться в виде одной из трех прикладных реализаций:

* Интерактивный или автономный SQL дает возможность пользователям непосредственно извлекать информацию из базы данных или записывать ее в базу.
* Статический SQL – фиксированный (исполняемый), записанный заранее, а не генерируемый во время выполнения программы код SQL. Существует две версии статического SQL. Встроенный SQL – это код SQL, включенный в код исходного текста программы, написанной на другом языке. Другое использование статического SQL – модульный язык. В этом случае модули SQL скомпонованы с модулями кода других языков.
* Динамический SQL – код SQL, сгенерированный приложением во время исполнения. Он заменяет статический SQL в тех случаях, когда необходимый код SQL еще не может быть определен во время написания приложения, так как сам код зависит от того, какой выбор сделает пользователь (во время реализации приложения). Операторы динамического SQL часто генерируются такими средствами разработки, как, например, графические языки запросов (реализующие запросы пользователя).

---

<a name="39"></a> [⇪⇪⇪](#0)

### 27.	Основные понятия языка SQL.

SQL отличается от языков программирования высокого уровня несколькими признаками. Во-первых, он относится к непроцедурным языкам. На языке типа COBOL или С можно записать для компьютера шаг за шагом все инструкции, необходимые для исполнения задания. SQL просто декларирует, что нужно делать, а исполнение возлагает на СУБД. Такой подход лежит в русле философии реляционных баз данных. СУБД в данном случае рассматривается как «черный ящик»: что делается внутри него – пользователя не касается. Его интересует только получение правильного ответа из базы данных и внесение в нее необходимых изменений. Ограничивая пользователя в вопросах исполнения операторов, SQL позволяет упростить сами операции и обеспечивает гибкость при реализации баз данных.

Другим важным преимуществом SQL является трехзначная логика (3VL). В большинстве языков используются булевы выражения, которые могут принимать только два значения: TRUE (истина) и FALSE (ложь). Язык SQL позволяет записывать в базу данных значение NULL (неопределенное значение). NULL является маркером, используемым для заполнения пространства в столбце, где по какой либо причине отсутствуют данные. (Значение может быть неприменимо, как, например, цвет волос в отношении птицы; может отсутствовать, как, например, цвет волос у лысого человека; и может быть неизвестным, как, например, цвет волос у человека в маске). Результатом применения арифметических операторов к NULL и другому значению, содержащему NULL, должно быть значение NULL. Когда значение NULL используется при сравнении, булево значение результата сравнения будет ни TRUE и ни FALSE, а UNKNOWN. 

Традиционно операторы SQL были разбиты на категории в соответствии с их функциями. Ниже приведены три категории, традиционно использующихся при обсуждении вопросов, связанных с базами данных:

* Язык определения данных (Data Definition Language – DDL) включает в себя все операторы, используемые для определения схем и объектов внутри схем. Наиболее важные операторы DDL применяются для создания различных объектов, например, операторы CREATE SCHEMA, CREATE TABLE, CREATE VIEW, CREATE ASSERTION и CREATE DOMAIN.
* Язык манипулирования данными (Data Manipulation Language – DML) включает все операторы, которые используются для записи, изменения и поиска данных в таблицах. Основные операторы этого языка: SELECT, INSERT, UPDATE и DELETE. Оператор SELECT применяется для формирования запросов, и, возможно, является наиболее сложным из одиночных операторов SQL. Остальные операторы используются для манипулирования данными в рамках таблиц.
* Операторы управления данными (Data Control Statements). Эта группа содержит операторы, которые используются для того, чтобы определить, что могут и чего не могут делать пользователи с объектами базы данных. Основными операторами этой категории являются GRANT и REVOKE (отмена).


---

<a name="40"></a> [⇪⇪⇪](#0)

### 28. Объекты и операторы языка определения данных.

Язык определения данных (Data Definition Language – DDL) включает в себя все операторы, используемые для определения схем и объектов внутри схем. Наиболее важные операторы DDL применяются для создания различных объектов, например, операторы CREATE SCHEMA, CREATE TABLE, CREATE VIEW, CREATE ASSERTION и CREATE DOMAIN.

---

<a name="41"></a> [⇪⇪⇪](#0)

### 29. Операторы языка манипулирования данными и их назначение.

Язык манипулирования данными (Data Manipulation Language – DML) включает все операторы, которые используются для записи, изменения и поиска данных в таблицах. Основные операторы этого языка: SELECT, INSERT, UPDATE и DELETE. Оператор SELECT применяется для формирования запросов, и, возможно, является наиболее сложным из одиночных операторов SQL. Остальные операторы используются для манипулирования данными в рамках таблиц.

---

<a name="42"></a> [⇪⇪⇪](#0)

### 30. Нормализация таблиц. (Первая нормальная форма. Вторая нормальная форма. Третья нормальная форма. Доменно-ключевая нормальная форма. Денормализация)

<a name="42.1"></a> [⇪⇪⇪](#0)

#### Первая нормальная форма.

Любая таблица, удовлетворяющая определению отношения, находится в 1НФ. 

Вот основные характеристики таблицы в 1НФ: 

* В каждой строке таблицы должны содержаться данные, соответствующие некоторому объекту или его части; 
* В каждом столбце должны находиться данные, соответствующие одному из атрибутов отношения; 
* В каждой ячейке таблицы должно находиться только единственное значение; 
* У каждого столбца должно быть уникальное имя; 
* Все строки (записи) в таблице должны быть различными; 
* Порядок расположения столбцов и строк в таблице не имеет значения. 

Таблица (отношение) в 1НФ свободна от некоторых аномалий, но все же подвержена многим другим. Например, таблица1 находится в 1НФ, но, как уже было отмечено, подвержена аномалиям удаления и добавления записей. 

<a name="42.2"></a> [⇪⇪⇪](#0)

#### Вторая нормальная форма.

Каждая таблица в 1НФ должна иметь первичный ключ. Он может состоять из одного или более столбцов (атрибутов). В последнем случае ключ называется составным. Чтобы таблица была в 2НФ, все ее не ключевые столбцы должны однозначно определяться всем ключом, т. е. всеми его компонентами, а не некоторыми из них.

Рассмотрим пример отношения. Таблица: Секции.

| Имя     | Секция   | Оплата |
| ------- | -------- | ------ |
| Иванов  | Футбол   | 100    |
| Иванов  | Волейбол | 120    |
| Петров  | Лыжи     | 170    |
| Сидоров | Шахматы  | 200    |
| Сидоров | Лыжи     | 170    |
| Фёдоров | Лыжи     | 170    |
| Фёдоров | Волейбол | 120    |

Ключом в данном отношении является {имя, Секция}, но оно содержит функциональную зависимость секция - плата. Аргумент. (левая часть) этой зависимости является лишь частью составного ключа. Отношение секции имеет аномалии удаления и добавления. Так, если мы захотим удалить записи с именем "иванов", то потеряем стоимость футбольной секции. Мы не сможем добавить запись о новой секции, пока в нее кто-нибудь не запишется. Данных аномалий можно было бы избежать, если бы атрибут плата зависел от всего ключа (однозначно определялся всем ключом). 

Отношение секции (Имя, Секция, Плата) в 1НФ можно разбить на два отношения во 2НФ: 

* Секция_члены (Имя, Секция); 
* Секция_плата (Секция, Плата). 

<a name="42.3"></a> [⇪⇪⇪](#0)

#### Третья нормальная форма.

В отношениях могут быть так называемые транзитивные зависимости, являющиеся источником аномалий модификации данных, против которых 2НФ бессильна. Транзитивная зависимость имеет место тогда, когда один атрибут однозначно определяет второй, второй однозначно определяет третий и т. д. 

Рассмотрим в качестве примера отношение гости (ID_гостя, тип_номера, плата), представляющее сведения о проживающих в гостинице. Ключом в этом отношении является ID_гостя, плата однозначно определяется атрибутом тип номера (например, люкс, полулюкс и т. д.), т. е. имеется функциональная зависимость тип номера - > плата. Поскольку каждый гость проживает только в одном номере определенного типа, в отношении есть и функциональная зависимость ID_гостя - >тип_номера. Таким образом, возникает транзитивная (опосредованная) зависимость  ID_гостя-> плата. Так как ключ состоит из единственного атрибута ID_гостя, то отношение находится в 2НФ. 

В рассматриваемом отношении существует аномалия удаления. Удалив запись, мы потеряем не только информацию о каком-то госте (где он проживает), но и сведения о том, сколько стоит номер соответствующего типа. 

Чтобы устранить указанную аномалию, следует декомпозировать 
исходное отношение гости (ID_гостя, Тип_номера, плата) на два: 

* Проживание (ID_гостя, Тип_номера); 
* Тип плата (Тип_номера, Плата). 

Эти отношения будут находиться в 2НФ и не содержать транзитивных зависимостей. 

Таким образом, отношение находится в 3НФ, если оно находится в 2НФ и не содержит транзитивных зависимостей. 

<a name="42.4"></a> [⇪⇪⇪](#0)

#### Доменно-ключевая нормальная форма.

Если таблица находится в ЗНФ, то остается довольно мало шансов для возникновения аномалий модификации данных, но они все равно есть. Чтобы исключить все виды возможных аномалий, таблица должна находиться в доменно-ключевой нормальной форме (ДКНФ). 

Понятие ДКНФ довольно просто: отношение находится в ДКНФ, если каждое ограничение, накладываемое на него, является логическим следствием определения доменов и ключей. Термин ограничение (constraint) здесь намеренно трактуется широко. Р. Фагин определяет ограничение как любое правило, регулирующее возможные статические значения атрибутов, достаточно точное, чтобы можно было проверить его выполнимость. Правила редактирования, ограничения взаимосвязей и структуры отношений, функциональные и многозначные зависимости являются примерами таких ограничений. Отсюда исключаются ограничения, связанные с изменением данных (ограничения, зависящие от времени). Другими словами, отношение находится в ДКНФ, если выполнение ограничений на домены и ключи влечет за собой выполнение всех ограничений. 

Однако в настоящее время не известен алгоритм преобразования отношения в ДКНФ. Неизвестно также, какие отношения в принципе могут быть приведены к ДКНФ. Поиск и создание отношений в ДКНФ сейчас является искусством, а не наукой. В литературе обычно приводятся только примеры отношений в ДКНФ, которые мы здесь рассматривать не будем. 

<a name="42.5"></a> [⇪⇪⇪](#0)

#### Денормализация 

Чтобы исключить как можно больше аномалий модификации данных, старайтесь как можно больше нормализовать таблицы базы данных. Лучше, если вы доведете их до ДКНФ, хотя на практике это редко происходит. Чаще ограничиваются второй или третьей нормальными формами. Занимаясь нормализацией, вы увеличиваете количество таблиц в базе данных, и при определенном их количестве эффективность работы может оказаться слишком низкой. Кроме того, формулировать SQL-запросы к базе данных тем легче, чем меньше в ней таблиц. Так что на любом этапе своего развития база данных может быть в какой-то степени денормализованной. 

---

<a name="43"></a> [⇪⇪⇪](#0)

### 31. Ограничения целостности отношений.

<a name="44"></a> [⇪⇪⇪](#0)

#### 31.1. Семантическая целостность.

<a name="45"></a> [⇪⇪⇪](#0)

#### 31.2. Доменная целостность.

<a name="46"></a> [⇪⇪⇪](#0)

#### 31.3. Ссылочная целостность.

---

<a name="47"></a> [⇪⇪⇪](#0)

### 32. Типы данных.

<a name="48"></a> [⇪⇪⇪](#0)

#### 32.1. Строковый (символьный).

Строковые данные (последовательности символов) имеют три главных строковых типа. Для столбца таблицы можно указать тип **CHARACTER(n)** или **CHAR(n)** (строка фиксированной длины), где n - максимальное количество символов, содержащихся в строке. Если (n) не указано, то предполагается, что строка состоит из одного символа. Если в столбец типа **CHARACTER(n)** вводится m< n символов, то оставшиеся позиции заполняются пробелами. 

Тип данных **CHARACTER VARYING(n)** или **VARCHAR(n)** (строка переменной длины) применяется тогда, когда вводимые данные имеют различную длину и нежелательно дополнять их пробелами. При этом сохраняется только то количество символов, которое ввел пользователь. В данном случае указание максимального количества символов обязательно (в отличие от CHARACTER). 

Данные типов **CHARACTER** и **CHARACTER VARYING** могут участвовать в одних и тех же строковых операциях. 
Тип данных **CHARACTER LARGE OBJECT** (**CLOB** - большой символьный объект) используется для представления очень больших символьных строк (например, статей, книг и т. п.). В некоторых СУБД данный тип называется MEMO, а в других - text. С данными этого типа можно выполнять не все операции, предусмотренные для типов **CHARACTER** и **CHARACTER VARYING**. Так, их нельзя использовать в операциях сравнения, за исключением равенства и неравенства. Кроме того, столбцы этого типа не могут быть первичными и внешними ключами, а также быть объявлены как имеющие уникальные значения. Иначе говоря, при создании таблиц с помощью оператора **CREATE** и объявлении столбцов типа CLOB нельзя использовать ключевые слова **PRIMARY KEY**, **FOREIGN KEY** и **UNIQUE**. 

В следующем примере создается таблица с обычным символьным столбцом и столбцом типа CLOB, значения которого могут содержать 100 000 символов: 

    CREATE TABLE myTable ( 
        FIELD1 CHARACTER(60), 
        FIELD2 CLOB (100000) 
    ); 

Здесь оператор **CREATE TABLE** создает таблицу с именем myTable,.' -'. которая состоит из двух столбцов с именами FIELD1 и FIELD2, типы столбцов указаны рядом с их именами. 

Различные языки используют различные наборы символов. Даже английский и немецкий наборы отличаются, не говоря уж о русском и китайском. Система может быть настроена на некоторый набор символов, принимаемый по умолчанию. Однако при этом можно использовать и другие национальные символьные наборы. Так, в следующем примере создается таблица, в которой столбец FIELD1 объявляется как строковый с набором символов, принятым по умолчанию, а столбец FIELD 2 - как строковый с греческим набором символов: 

    CREATE TABLE myTable ( 
        FIELD1 CHARACTER (60), 
        FIELD2 CHARACTER VARYING (80) CHARACTER SET GRЕК 
    );

Значения строкового типа в SQL-выражениях заключаются в одинарные кавычки. Например, 

    'иванов иван иванович', ‘12345 рублей’, ‘тел -.(812) 123-456 '. 

Пустая строка не содержит ни одного символа и имеет вид: ''. Строка, содержащая один или более пробелов, не является пустой. 

Иногда бывает так, что строковый столбец в таблице содержит только числа (точнее, строки, содержащие цифры, знаки числа и разделительные точки). Чтобы использовать такие данные в операциях с числами, необходимо привести данные одного типа к другому типу с помощью функции **CAST()**. 

Значения типа **CHARACTER** и **CHARACTER VARYING (VARCHAR)** совместимы в том смысле, что они могут участвовать как операнды в строковых операциях и операциях сравнения.

<a name="49"></a> [⇪⇪⇪](#0)

#### 32.2. Числовой.

Числовой тип данных может быть двух видов - точный и приблизительный. Точные числовые типы позволяют точно выразить значение числа. Некоторые величины имеют очень большой диапазон значений, и в таких случаях достаточно ограничиться некоторым приближенным их представлением с учетом технических возможностей компьютера (размеров регистра). 

К точным числовым относятся следующие пять типов: 

* **INTEGER** - целое (без дробной части) число. Количество разрядов (точность) зависит от реализации SQL. В некоторых реализациях числа этого типа лежат в диапазоне от - 2 147 483 648 до 2 147 483 647 (четырехбайтное целое число); 
* **SMALLINT** - малое целое число. Количество разрядов зависит от реализации SQL, но не больше количества разрядов INTEGER в этой же реализации. В некоторых реализациях числа этого типа лежат в диапазоне от -32768 до 32767 (двухбайтное целое число); 
* **BIGINT** - большое целое число. Количество разрядов зависит от реализации SQL и превышает количество разрядов числа типа INTEGER. 
* **NUMERIC(x, у)** - число, в котором всего х разрядов (точность), из которых у разрядов (масштаб) отводится для дробной части. Если y не указано (NUMERIC(x)), то для дробной части отводится количество разрядов, установленное в системе по умолчанию. Если не указаны ни х, ни у (NUMERIC), то принимаются обе эти величины, установленные по умолчанию. Например, если указан тип NUMERIC(6, 2), то максимальное значение числа равно 9999. 99; 
* **DECIMAL(x, у)** - десятичное число, в котором всего х разрядов, из которых у разрядов отводятся для дробной части. Если х или/и.у не указаны, то принимаются значения по умолчанию. Этот тип очень похож на NUMERIC. Отличие состоит в том, что если в DECIMAL(x, у)  указанные х и у меньше, чем допустимые реализацией SQL, то будут использоваться последние. Если х и у не указаны, то применяется система умолчаний. Например, вы задали для столбца тип DECIMAL(6, 2). Если реализация SQL позволяет, то в этот столбец можно ввести числа, превышающие 9999. 99. В отличие от DECIMAL(x, у), тип NUMERIC(x, у) жестко задает диапазон возможных значений числовой величины. 

К приблизительным числовым типам относятся следующие три типа: 

* **REAL** - вещественное число одинарной точности с плавающей разделительной точкой (эта точка "плавает", появляясь в различных местах числа). Например, 5.25, 5.257, 5.2573. Точность представления числа зависит от реализации SQL и оборудования. Например, 32-битовый компьютер дает большую точность, чем 16-битовый; 
* **DOUBLE PRECISION** - вещественное число двойной точности с плавающей разделительной точкой. Точность представления числа зависит от реализации SQL и оборудования. Применяется для представления научных данных (например, результатов измерений) в широком диапазоне значений, т. е. как очень малых (близких к 0), так и очень больших; 
* **FLOAT(x)** - вещественное число с плавающей разделительной точкой и минимальной точностью х, занимающее не более 8 байтов. Если компьютер может поддержать указанную точность, используя аппаратную одинарную точность, то система будет использовать арифметику одинарной точности. Если указанная точность требует арифметики с двойной точностью, то система будет использовать ее. Данный тип следует применять, если предполагается возможность переноса базы данных на другую аппаратную платформу, отличающуюся размерами регистров. Пример значения типа FLOAТ: 5.318Е-24 (т. е. 5.318, умноженное на 10 в степени -24). Такую же форму представления имеют и числа типа REAL И DOUBLE PRECISION. 

<a name="50"></a> [⇪⇪⇪](#0)

#### 32.3. Логический (булевский).

Данные логического типа получаются в результате операций сравнения. Например, результатом вычисления выражения 3 < 5 является ИСТИНА, а выражения 2 + 3 = 10 - ЛОЖЬ. 

В SQL тип данных BOOLEAN (булевский) имеет три значения- true, false и unknown. Значение unknown (неизвестное) было введено для обозначения результата, получающегося при сравнении со значением NULL (неопределенное). Если пользователь еще не ввел в ячейку таблицы никакого значения, то эта "пустая" ячейка содержит значение NULL, интерпретируемое как неизвестное или неопределенное значение. 

Результатом любой операции сравнения true или false с NULL, или с unknown всегда является unknown. 
В SQL-выражениях логические значения заключаются в кавычки, например, 'TRUE' или 'true'. 

<a name="51"></a> [⇪⇪⇪](#0)

#### 32.4. Дата и время.

Тип **DATA (дата)** предназначен для хранения значений даты, элементы которых расположены в следующем порядке: год (4 цифры), дефис (-), месяц (2 цифры), дефис, день (2 цифры). Таким образом, значения даты занимают 10 позиций, например, 

    2005-10-02. 

Данные этого типа могут содержать любую дату с 0001 года по 9999 год.\
Для представления времени предусмотрены два типа: 

**TIME WITHOUT TIME ZONE** (время без часового пояса) предназначено для хранения значений времени, элементы которых расположены в следующем порядке: часы, двоеточие, минуты, двоеточие, секунды. Часы и минуты представляются двумя цифрами, а секунды могут быть представлены двумя и более цифрами (если требуется дробная часть), например 

    18:35:19.547. 

Длина дробной части секунд зависит от реализации, но внутреннее представление времени должно иметь не менее 6 цифр. По умолчанию время данного типа представляют без дробной части секунд. Чтобы указать, что время должно быть представлено с n цифрами после разделительной точки, достаточно использовать такой синтаксис: **TIME WITHOUT TIME ZONE(n)**. Например, чтобы кроме секунд указывались еще и миллисекунды, следует определить тип как TIME WITHOUT TIME ZONE (3) Длина, данных рассматриваемого типа без дробной части равна 8 символам, а с дробной частью - 9 плюс количество цифр после разделительной точки. Для задания времени без указания часового пояса с использованием установок по умолчанию можно использовать короткий синтаксис - **TIME**; 

**TIME WITH TIME ZONE** (время с часовым поясом) - такой же тип данных, как и **TIME WITHOUT TIME ZONE**. Отличие заключается лишь в том, что к значению времени добавляется еще и информация о разности между местным и всемирным временем. Всемирное время (Universal Time Coordinated, UTC) - это время по Гринвичу, т. е. время нулевого меридиана, проходящего через г. Гринвич в Великобритании (Greenwich Меап Nime, GMT). Значение разности между локальным и всемирным временем находится в диапазоне от -12:59 до 13:00. Длина данных рассматриваемого типа равна длине данных типа TIME WITHOUT TIME ZONE плюс 6, поскольку дополнительная информация о разности времен занимает 6 позиций (дефис, знак (+) или (-), 2 цифры для часов, двоеточие, 2 цифры для минут). 

Для одновременного представления даты и времени служат следующие два типа: 

**TIMESTAMP WITHOUT TIME ZONE** (дата и время без часового пояса). Элементы данных этого типа имеют такие же характеристики, как и для данных типа DATE И TIME WITHOUT TINE ZONE, за исключением одного: данные типа TIMESTAMP WITHOUT. 

**TIME ZONE** по умолчанию имеют 6 цифр в дробной части секунд, а не 0, как в типе **ТIME WITHOUT TIME ZONE**. Для указания количества цифр в дробной части используется синтаксис **TIMESTAMP WITHOUT TIME ZONE (n)**. Если дробной части нет, то данные занимают 19 позиций: 10 позиций для даты, один пробел и 8 позиций для времени. Если определена дробная часть, то длина данных равна 20 плюс количество цифр в дробной части секунд; 

**TIMESTAMP WITH TIME ZONE** (дата и время с часовым поясом) - такой же тип данных, как и **ТIME WITHOUT TIME ZONE**. Отличие состоит в том, что к значению времени добавляется еще и информация о разности между местным и все- мирным временем. Дополнительная информация занимает 6 позиций. Данные типа TIMESTAMP WITH TIME ZONE без дробной части занимают 25 позиций, с дробной частью - 26 плюс количество цифр в дробной части секунд. 

Чтобы представить в SQL-выражении дату, время или дату- время, необходимо использовать функцию CAST() приведения к заданному типу. Допустим, в таблице продажи имеется столбец дата типа DATA. Чтобы получить сведения из этой таблицы за период после 2005-09-30, следует выполнить такой запрос: 

    SELECT * 
    FROM продажи 
    WHERE Дата > CAST('2005-09-30' AS DATE); 
    
Здесь строка, содержащая дату, приводится к типу DATA, и полученный результат участвует в операции сравнения с данными столбца Дата. 

В языке SQL имеются три функции, которые возвращают текущие дату и время: 

* **CURRENT DATE** - возвращает текущую дату (тип DATE). На- 
пример, 2005-06-18; 
* **CURRENT_TIME(число)** - возвращает текущее время (тип TIME). Целочисленный параметр число указывает точность представления секунд. Например, при число = 2 секунды будут представлены с точностью до сотых (две цифры в дробной части): 12:39:45.27; 
* **CURRENT_TIMESTAMP(число)** - возвращает дату и время (тип TIMESТАМР), например 2005-06-18 12:39:45.27. Целочисленный параметр число указывает точность представления секунд.

<a name="52"></a> [⇪⇪⇪](#0)

#### 32.5. Интервалы.

Интервал представляет собой разность между двумя значениями типа дата-время. SQL поддерживает два типа интервалов: год- месяц и день-время. Интервал типа год-месяц - это количество лет и месяцев между двумя датами, а интервал день-время - количество дней, часов, минут и секунд между двумя моментами в пределах одного месяца. Нельзя смешивать вычисления, использующие интервал год-день, с вычислениями, в которых используется интервал день-время. 
Интервал времени можно задать двумя способами: в виде начального и конечного моментов или в виде начального момента и длительности, например: 

    (TIME '12:25:30', TIME '14:30:00') - интервал, заданный начальным и конечным моментами; 
    (TIME '12:45:00', INTERVAL '5' HOUR) - интервал, заданный начальным моментом и длительностью в часах. 

Чтобы задать значение типа интервал, используется такой синтаксис: 

    INTERVAL 'длина' YEAR | MONTH | DAY | HOUR | MINUTE | SECOND 

Здесь длина - длина интервала, после которой указывается единица измерения (возможные значения указаны через вертикальную черту): 

* YEAR - год; 
* MONTH - месяц; 
* DAY - день; 
* HOUR - час; 
* MINUTE - минута; 
* SECOND - секунда. 

Например, для задания интервала длиной 15 дней следует использовать выражение INTERVAL '15' DAY. 

<a name="53"></a> [⇪⇪⇪](#0)

#### 32.6. Специальные типы данных.

* Row (запись), 
* ARRAY (массив) и 
* MULTISET (мультимножество). 

В следующем примере на основе типа ROW создается тип addr, а затем он назначается столбцу Адрес при создании таблицы клиенты. 

    CREATE ROW TYPE addr ( 
        PostCode    VARCHAR (9), 
        City        VARCHAR (30), 
        Street      VARCHAR (30),
        House       VARCHAR (10)  
    );

    CREATE TABLE клиенты (
        ID_клиента  INTEGER PRIMARY KEY,
        Имя 	VARCHAR(25), 
        Адрес 	addr,
        Телефон     VARCHAR(15) 	
    );

Пример, в котором каждая ячейка столбца телефон может содержать до трех номеров телефона: 

    CREATE TABLE Клиенты ( 
        ID_клиента 	INTEGER PRIMARY KEY, 
        Имя 	VARCHAR(25),
        Адрес 	addr, 
        Телефон     VARCHAR(15) ARRAY[3] 
    );

Следующее SQL-выражение добавляет в таблицу клиенты новую запись и вводит в нее значения столбцов: 

    INSERT INTO Клиенты (Имя, Телефон) 
    VALUES ('Петров Петр Петрович', ('444-4444', '123-4567', '777-8899')); 


<a name="54"></a> [⇪⇪⇪](#0)

#### 32.7. Пользовательские типы данных.

##### Отдельные типы.

Синтаксис создания отдельного типа данных такой: 

    CREATE DISTINCT TYPE имяТипа AS определенныйТип; 

Определим в качестве примера тип MONEY для хранения денежных сумм. С этой целью можно воспользоваться уже определенным 

числовым типом DECIMAL: 

    CREATE DISTINCT TYPE MONEY AS DECIMAL (9,2); 

По аналогии с типом MONEY можно создать типы данных для различных валют, чтобы исключить возможность сравнения их просто как обычных чисел: 

    CREATE DISTINCT TYPE EURO AS DECIMAL (9,2); 
    CREATE DISTINCT TYPE USD AS DECIMAL (9,2);
    CREATE DISTINCT TYPE RU AS DECIMAL (9,2);

Предположим, что курс доллара к рублю изменился, и мы хотим изменить цены в рублях. Если бы столбцы цена_USD и цена_RU были одного и того же типа, то данную операцию можно было бы выполнить с помощью следующего SQL-выражения: 

    UPDATE Прайс_лист SET Цена_RU = k * Цена_USD 

Здесь k — коэффициент конвертации. 
Но поскольку столбцы цена_USD и цена_RU  имеют различные типы, то необходимо выполнить такое выражение: 

    UPDATE Прайс_лист 
    SET CAST(Цена_RU AS DECIMAL (9,2) = k * CAST(Цена_USD 
    AS DECIMAL (9,2));  

##### Структурированные типы.

При создании структурированного типа СУБД автоматически создает для него три функции: 

* функцию-конструктор с именем, совпадающим с именем создаваемого типа; 
* функцию-мутатор, с помощью которой можно изменить значение атрибута создаваемого типа; 
* функцию-наблюдатель, позволяющую узнать значение атрибута создаваемого типа. 

Рассмотрим пример, в котором создаются некий тип и его подтип данных, таблица со столбцом созданного типа, а также блок операторов SQL, которые производят изменения данных в таблице. Вначале создадим тип данных Book, содержащий сведения (атрибуты) о книгах, затем создадим его подтип myBooks, который наследует атрибуты своего супертипа Books. 

    CREATE TYPE Books AS 
    Title 		CHAR (50), 
    Author 	        CHAR (20), 
    Publisher 	CHAR (20),  
    Year 		INTEGER, 
    Volume 	        INTEGER, 
    N0T FINAL; 

Здесь в типе Books (книги) определяются атрибуты (имена и типы данных): 
Title (наименование), Author (автор), Publisher (издательство), Year (год издания), Volume (количество страниц). Ключевые слова N0T FINAL (не конец) означают, что данный тип имеет хотя бы один подтип. 

Определим подтип myBooks для хранения данных, например, о моих любимых книгах: 

    CREATE TYPE myBooks UNDER Books FINAL; 

По-русски это выглядит как: 

    СОЗДАТЬ ТИП myBooks ПОД Books ЗАКОНЧИТЬ; 

Создадим таблицу, которая использует тип myBooks 

    CREATE TABLE Книги( 
        Книга myBooks, 
        Цена NUMERIC (6,2) 
    );

Теперь добавим новые записи в созданную таблицу книги. 

    BEGlN 
    DECLARE х myBooks;   /* объявление переменной х типа myBooks*/ 
    SET х = myBooks(); /* Вьполняем функцию-конструктор */ /* Вызов функций-мутаторов */ 
    SET х = х.Title('HTML, скрипты и стили');
    SET х = х .Author('Дунаев Вадим'); 
    SET х = х.Publisher('БХВ-Петербург');
    SET х =х.Year(2005);
    SET х.Volume(832); 
    /* Добавление новой записи с установкой значений столбцов */ INSERT INTO книги (х, 350.50) 
    END;

Здесь ключевые слова BEGIN (начало) и END (конец).
В следующем примере из таблицы Клиенты выбираются все записи, в которых не определено имя клиента: 

    SELECT * FROM Клиенты WHERE ИМЯ IS NULL; 

---


<a name="55"></a> [⇪⇪⇪](#0)

### 33. Преобразование типов.

Чтобы выполнить какую-либо операцию над данными различных типов, необходимо сделать преобразование типов. Точнее, необходимо выполнить приведение данных одного типа к другому типу, чтобы участвующие в операции данные были либо однотипными, либо их типы были соответствующими. Соответствующими типами являются: 

* строковые CHARACTER и CHARACTER VARYING; 
* все числовые типы; 
* дата, время, дата-время и соответствующие интервалы.
  
Соответствующие типы не обязательно приводить друг к другу. Приведение значения одного типа к другому осуществляется с помощью функции CAST ():

    CAST (выражение AS тип); 

Например: 

    CAST ('1234.52' AS NUMERIC (9, 2) ); 
    CAST ('2005-10-03 ' AS DATE); 
    CAST (CURRENT TIMESTAMP (2) AS CHAR (20) );
    SELECT 'Цена: ' || CAST (Цена AS CHAR(5) ) FROM Продажи; 

В последнем примере пара вертикальных черт означает операцию конкатенации строк. 

---

<a name="56"></a> [⇪⇪⇪](#0)

### 34. SQL-выражение для выборки данных.

Чтобы выбрать из таблицы базы данных требуемые записи, следует, по крайней мере, указать столбцы и имя этой таблицы. Это требование было бы естественно сформулировать так: 

    ВЫБРАТЬ такие-то столбцы ИЗ такой-то таблицы; 

Разумеется, вам может потребоваться выбрать не все записи таблицы, а лишь те, которые отвечают некоторому условию. На практике именно так и бывает. Отложим пока рассмотрение формирования условий отбора записей, а сконцентрируем внимание на выборке всех записей из заданной таблицы. 
SQL-запрос к базе данных, результатом которого является таблица, полученная из указанной в запросе, но отличающаяся от нее тем, что содержит лишь указанные столбцы, выглядит так: 

    SELECT списокСтолбцов FROM списокТаблиц; 

Операторы SELECT (выбрать) и FROM (из) в SQL-выражении, 

Так, например, если исходная таблица R содержит столбцы A1, A2, ...,An (другими словами, таблица представляет некоторое отношение R(A1, А2, ..., An) над атрибутами (А1, А2, ..., An), то оператор: 

    SELECT A1, A2, Ak FROM R; 

реализует проекцию R[A1, А2, Аk] этого отношения на атрибуты А1, А2, Ak (k= 1, 2, ..., n). 

Тривиальный запрос, возвращающий все данные (все столбцы и все записи) из одной таблицы, формулируется так: 

    SELECT * FROM имяТаблицы; 

Основное SQL-выражение может быть дополнено другими операторами, уточняющими запрос. Чаще всего употребляется оператор WHERE (где), с помощью которого можно задать условие выборки записей (строк таблицы). Таким образом, если выражение SELECT задает столбцы таблицы, указанной в операторе FROM то выражение WHERE определяет записи (строки) из этой таблицы. Выражение, определяющее запрос на выборку данных, находящихся в некоторой таблице, имеет следующий вид: 

    SELECT * FROM имяТаблицы WHERE условиеПоиска; 

Условие, указанное в выражении WHERE, принимает одно из двух логических значений: true (ИСТИНА) или false (ЛОЖЬ). 
Ключевые слова: ALL(все), DISTINCT(отличающиеся)

Например: 

    SELECT ClientName AS Клиент, Address AS Адрес FROM Клиенты; 

Псевдонимы таблиц, более короткие, чем их имена, удобно использовать в сложных запросах. 

Например: 

    SELECT Tl.Имя, Т2.Адрес FROM Клиенты Т1, Контакты T2; 

#### Уточнения запроса 

Основное SQL-выражение для выборки данных, имеет вид: 

    SELECT списокСталбцов FROM списокТаблиц; 

Для уточнения запроса на выборку данных служит ряд дополнительных операторов: 

* WHERE (где) — указывает записи, которые должны войти в результатную таблицу (фильтр записей); 
* GROUP BY (группировать по) — группирует записи по значениям определенных столбцов; 
* HAVING (имеющие, при условии) — указывает группы записей, которые должны войти в результатную таблицу (фильтр групп); 
* ORDER BY (сортировать по) — сортирует (упорядочивает). 

Таким образом, запрос данных из таблицы с применением всех перечисленных операторов уточнения запроса имеет следующий вид:

    SELECT списокСтолбцов 
    FROM имяТаблицы 
    WHERE условиеПоиска 
    GROUP BY столбец группировки 
    HAVING условиеПоиска 
    ORDER BY условиеСортировки; 

Порядок перечисления операторов в SQL-выражении не совпадает с порядком их выполнения. Однако знание порядка выполнения операторов поможет вам избежать многих недоразумений. Итак, перечисленные операторы SQL-выражения выполняются в следующем порядке, передавая друг другу результат в виде таблицы: 

1. **FROM** — выбирает таблицу из базы данных; если указано несколько таблиц, то выполняется их декартово произведение и результирующая таблица передается для обработки следующему оператору. 
2. **WHERE** — из таблицы выбираются записи, отвечающие условию поиска, и отбрасываются все остальные. 
3. **GROUP BY** — создаются группы записей, отобранных с помощью оператора  WHERE (если он присутствует в SQL-выражении); каждая группа соответствует какому-нибудь значению столбца группирования. Столбец группирования может быть любым столбцом таблицы, заданной в операторе FROM, а не только тем, который указан в SELECT. 
4. **HAVING** — обрабатывает каждую из созданных групп записей, оставляя только те из них, которые удовлетворяют условию поиска; этот оператор используется только вместе с оператором GROUP BY. 
5. **SELECT** — выбирает из таблицы, полученной в результате применения перечисленных операторов, только указанные столбцы. 
6. **ORDER BY** — сортирует записи таблицы. При этом в условии сортировки можно обращаться лишь к тем столбцам, которые указаны в операторе SELECT. 

Для этой цели подойдет следующее SQL-выражение: 

    SELECT Имя, Адрес 
    FROM Клиенты 
    WHERE Сумма заказа > 500;

    ВЫБРАТЬ СТОЛБЦЫ имя, Адрес 
    ИЗ ТАБЛИЦЫ клиенты 
    ГДЕ Сумма заказа > 500; 

Выбираются только те записи, в которых Сумма заказа превышает 500, и они группируются по значениям столбцов Регион, Имя и Адрес. Это означает, что в результатной таблице записи, имеющие одинаковые значения в столбце Регион, будут расположены рядом друг с другом. Наконец, все записи в результатной таблице упорядочиваются по значениям столбца Имя. 

    SELECT Регион, Имя, Адрес 
    FROM Клиенты 
    WHERE Сумма заказа > 500 
    GROUP BY Регион, Имя, Адрес 
    ORDER BY Имя; 


---

<a name="57"></a> [⇪⇪⇪](#0)

### 35. Оператор WHERE.

Условия поиска в операторе WHERE (где) являются логическими выражениями, т. е. принимающими одно из двух возможных зна- . чений — true (ИСТИНА) или false (ЛОЖЬ). Например, выражение Сумма заказа > 500 является истинным (имеет значение true), если в текущей записи таблицы значение столбца Сумма заказа превышает 500. В противном случае это выражение—  ложно (имеет значение false). Одно и то же логическое выражение может быть истинным для одних записей и ложным для других. Вообще говоря, в SQL логические выражения могут принимать еще и неопределенное значение. Эго происходит тогда, когда в выражении некоторые элементы имеют значение NULL. Таким образом, в SQL мы имеем дело не с классической двузначной, а с трехзначной логикой. 

Напомню, что выражение, следующее за оператором WHERE, возвращает одно из трех значений: true, false или NULL. При выполнении запроса (SQL-выражения) логическое выражение WHERE применяется ко всем записям исходной таблицы. Если оно истинно для данной записи исходной таблицы, то эта запись выбирается и будет представлена в результатной таблице; в против- ном случае запись не попадет в результатную таблицу. 

При составлении логических выражений используются специальные ключевые слова и символы операций сравнения, которые называют предикатами. Например, в выражении Сумма_заказа > 500 применен предикат сравнения(>). 

Наиболее часто используются предикаты сравнения, такие как (=), (<), (>), (<>), (<=) и (>=). Однако имеются и другие. Далее приведен список всех предикатов: 

* предикаты сравнения: (=), (<), (>), (<>), (<=), (>=); 
* BETWEEN; 
* IN, NOT IN; 
* LIKE, NOT LIKE;
* IS NULL; 
* ALL, SOME, ANY; 
* EXISTS;
* UNIQUE; 
* DISTINCT; 
* OVERLAPS; 
* MATCH;
* SIMILAR

---

<a name="58"></a> [⇪⇪⇪](#0)

### 36. Предикаты сравнения.

Предикаты сравнения, называемые также операторами сравнения, перечислены ниже. 

| Символ | Описание                      |
| ------ | ----------------------------- |
| =      | Равно                         |
| <>     | Не равно                      |
| <      | Меньше                        |
| <=     | Меньше или равно  (не больше) |
| >      | Больше                        |
| >=     | Больше или равно (не меньше)  |

---

<a name="59"></a> [⇪⇪⇪](#0)

### 37. BETWEEN.

Предикат BETWEEN (между) позволяет задать выражение проверки вхождения какого-либо значения в диапазон, определяемый граничными значениями. Например: 

    WHERE сумма_заказа BETWEEN 100 AND 750

Здесь ключевое слово AND представляет собой логический союз И. Граничные значения (в примере это 100 и 750) входят в диапазон. Причем первое граничное значение должно быть не больше второго. 

Эквивалентным приведенному является выражение с предикатами сравнения: 

    WHERE Сумма заказа >= 100 AND Сумма заказа <= 750 

Кроме данных числового типа, в выражениях с BEETWEEN МОЖНО использовать данные следующих типов: символьные, битовые, даты-времени, Так например, чтобы выбрать записи, в которых имена клиентов находятся в диапазоне от А до Ж, можно использовать такое выражение: 

    SELECT Имя, Адрес FROM Клиенты 
    WHERE Имя BETWEEN 'А' AND 'Ж'; 

---

<a name="60"></a> [⇪⇪⇪](#0)

### 38. IN, NOT IN.

Предикаты IN (в) и NOT IN (не в) применяются для проверки вхождения какого-либо значения в заданный список значений. Например, для выборки записей о клиентах из некоторых регионов можно использовать такое выражение: 

    SELECT Имя, Адрес FROM Клиенты 
    WHERE Регион IN ('Северо-запад', 'Ставропольский край', 'Иркутская область'); 

Если требуется получить данные обо всех клиентах не из Москвы и Северо-Запада, то можно использовать предикат NOT IN:

    SELECT имя, Адрес FROM Клиенты 
    WHERE Регион NOT IN (' Москва', 'Санкт-Петербург'); 

---

<a name="61"></a> [⇪⇪⇪](#0)

### 39. LIKE, NOT LIKE.

Предикаты LIKE (похожий) и NOT LIKE (не похожий) применяются для проверки частичного соответствия символьных строк. Например, столбец телефон в некоторой таблице содержит полные номера телефонов, а вам требуется выбрать лишь те записи, в которых номера телефонов начинаются с 348 или содержат такое сочетание цифр. 
Критерий частичного соответствия задается с помощью двух символов-масок: знака процента (%) и подчеркивания (_). Знак процента означает любой набор символов, в том числе и пустой, а символ подчеркивания - любой одиночный символ. 

Например, чтобы выбрать записи о клиентах, у которых номера телефонов начинаются с 348, можно использовать такое выражение: 

    SELECT Имя, Адрес, Телефон FROM Клиенты 
    WHERE Телефон LIKE '348%'; 

Допустим, столбец Адрес содержит полный почтовый адрес (индекс, название города, улицы и т. д.). Если вам требуется выбрать записи о клиентах, проживающих в Санкт-Петербурге, то для этого подойдет следующее выражение: 

    SELECT Имя, Адрес, Телефон 
    FROM Клиенты WHERE Адрес LIKE '%Санкт-Петербург% '; 

Если вы хотите исключить всех клиентов, проживающих в Москве, то воспользуйтесь таким выражением: 

    SELECT Имя, Адрес, Телефон 
    FROM Клиенты 
    WHERE Адрес NOT LIKE '%Москва%'; 

Возможно, вам потребуется выбрать записи, содержащие символы процента и/или подчеркивания. Тогда необходимо, чтобы такие символы воспринимались интерпретатором SQL не как символы-маски. Чтобы знак процента или подчеркивания воспринимался буквально, перед ним необходимо указать специальный управляющий символ. Этот символ можно определить произвольно, лишь бы он не встречался в качестве элемента данных. В следующем примере показано, как это можно сделать: 

    SELECT Имя, Адрес, Процент скидки 
    FROM Клиенты 
    WHERE Процент скидки LIKE '20#%' ESCAPE ' # '; 

Здесь за ключевым словом ESCAPE указывается символ, который используется в качестве управляющего. Таким же способом можно отключить и сам управляющий символ. 


---

<a name="62"></a> [⇪⇪⇪](#0)

### 40. IS NULL.

Предикат IS NULL применяется для выявления записей, в которых тот или иной столбец не имеет значения. Например, для получения записей о клиентах, для которых не указан адрес, можно использовать следующее выражение: 

    SELECT Имя, Адрес, Регион FROM Клиенты 
    WHERE Адрес IS NULL; 

Для получения записей, в которых столбец Адрес содержит некоторые определенные значения (т. е. отличные от NULL), можно использовать аналогичное выражение, но с логическим оператором NOT (не): 

    SELECT Имя, Адрес, Регион FROM Клиенты 
    WHERE Адрес IS NOT NULL; 

Не следует использовать предикаты сравнения с NULL, такие как 

    Адрес = NULL. 

---

<a name="63"></a> [⇪⇪⇪](#0)

### 41. ALL, SOME, ANY.

Предикаты АLL (все), SOME (некоторый), ANY (любой) в действительности представляют собой кванторы, известные в математической логике как кванторы всеобщности и существования.  ALL— квантор всеобщности, а SOME и ANY, являющиеся синонимами в SQL, — кванторы существования. Заметим, что в переводе на русский слово ANY следовало бы понимать как квантор всеобщности ("любой" означает "все"), однако в английском языке есть различные варианты значений этого слова. 
Применение ключевого слова ALL следует понимать как "для всех" или "для каждого". Ключевые слова SOME и ANY следует понимать как "хотя бы какой-нибудь один". 
В языке SQL ключевые слова SOME и ANY имеют одинаковый смысл, отличающийся от ALL. 

---

<a name="64"></a> [⇪⇪⇪](#0)

### 42. EXISTS.

Обработка данных часто состоит из нескольких этапов. Так, сначала производится некоторая выборка данных, а затем выполняются какие-то манипуляции с ней. Однако, выполняя запрос на выборку, мы далеко не всегда можем быть уверенными, что ответ содержит хотя бы одну непустую строку. Если ответ на запрос пуст, то бессмысленно производить дальнейшую обработку данных. Таким образом, полезно знать, содержит ли ответ на запрос какие-либо данные. Для этого предназначен предикат EXISTS (существует). Он становится истинным только тогда, кода результатная таблица, полученная в ответ на запрос, содержит хотя бы одну запись.

---

<a name="65"></a> [⇪⇪⇪](#0)

### 43. UNIQUE.

Предикат UNIQUE (уникальный) имеет такой же смысл, как и EXISTS, но при этом для его истинности требуется, чтобы все записи в результатной таблице не только существовали, но и были уникальны (т. е. не повторялись).

---

<a name="66"></a> [⇪⇪⇪](#0)

### 44. DISTINCT.

Предикат  DISTINCT (отличающийся, особый) почти такой же, как и UNIQUE. Отличие этих предикатов обнаруживается применительно к значениям NULL. Так, если в результатной таблице все записи уникальны (предикат UNIQUE истинен), то и предикат DISTINCT тоже истинен (т. е. если все записи уникальны, то они и отличающиеся). С другой стороны, если в результатной таблице имеются хотя бы две неопределенные записи, то предикат DISTINCT ложен, хотя предикат UNIQUE истинен.

---

<a name="67"></a> [⇪⇪⇪](#0)

### 45. OVERLAPS.

Предикат OVERLAPS (перекрывает) используется для определения, перекрываются ли два интервала времени. Интервал времени можно задать двумя способами: в виде начального и конечного моментов или в виде начального момента и длительности. Далее приведены примеры задания интервала времени: 

* (TIME '12: 25: 30’, TIME '14: 30: 00' ) — интервал заданный начальным и конечным моментами; 
* (TIME ' 12: 45: 00 ', INTERVAL ' 2 ' HOUR) — интервал, заданный начальным моментом и длительностью в часах. 

Выражение с предикатом OVERLAPS можно записать, например, так: 

    (TIME '12:25:30', TIME '14:30:00') OVERLAPS (TIME '12:45:00', INTERVAL '2' HOUR) 

Поскольку временные интервалы в данном примере пересекаются, то предикат OVERLAPS возвращает значение true. 



---

<a name="68"></a> [⇪⇪⇪](#0)

### 46. MATCH.

Предикат MATCH применяется для проверки сохранения ссылочной целостности при модификации данных, т. е. при добавлении, изменении и удалении записей.

---

<a name="69"></a> [⇪⇪⇪](#0)

### 47. SIMILAR.

Предикат SIMILAR (подобный) применяется для проверки частичного соответствия символьных строк. Эгу же задачу можно решить и с помощью предиката LIKE, однако в ряде случаев SIMILAR более эффективен. 
Предположим, что в некоторой таблице имеется столбец OC, содержащий названия операционных систем. Нужно выбрать записи, соответствующие Windows NT, Windows XP и Windows 98. Тогда в выражении запроса можно использовать такой оператор 
WHERE: 

    WHERE OC SIMILAR TO '(Windows (NT|XP|98))'; 

---

<a name="70"></a> [⇪⇪⇪](#0)

### 48. Оператор GROUP ВУ.

Оператор GROUP BY (группировать по) служит для группировки записей по значениям одного или нескольких столбцов. Если в SQL-выражении используется оператор WHERE, задающий фильтр записей, то оператор GROUP BY находится и выполняется после него. Для определения, какие записи должны войти в группы, служит оператор HAVING, используемый совместно с GROUP BY. Если оператор HAVING не применяется, то группировке подлежат все записи, отфильтрованные оператором WHERE. Если WHERE не используется, то группируются все записи исходной таблицы. О порядке выполнения операторов уже говорилось в начале. 

Допустим, что на основе таблицы о клиентах требуется сгруппировать данные о суммах заказов клиентов по регионам. Для этого можно воспользоваться следующим SQL выражением: 

    SELECT Регион, Сумма заказа FROM Клиенты
    GROUP BY Регион; 

результатная таблица: записи с одинаковыми названиями регионов расположены рядом друг с другом (в одной группе).

Чтобы получить таблицу, в которой суммы заказов подытожены по регионам, потребуется использовать итоговую функцию SUM()  и группировку по регионам: 

    SELECT Регион, SUM (сумма_заказа) 
    FROM Клиенты 
    GROUP BY Регион; 

Здесь в выражении SELECT указаны обычный столбец таблицы Клиенты и итоговая функция SUM(), вычисляющая сумму значений столбца сумма заказа. Поскольку группировка задана по столбцу Регион, То функция SUM (Cума_заказа) вычисляет суммы значений столбца сумма заказа для каждого значения столбца Регион. На рис.  показана результатная таблица на фоне исходной таблицы клиенты. Обратите внимание, что в этой таблице названия регионов не повторяются. 

Оператор GROUP BY собирает записи в группы и упорядочивает (сортирует) группы по алфавиту (точнее, по ASCII-кодам символов). Это обстоятельство следует иметь в виду перед тем, как принять решение об использовании оператора сортировки ORDER BY. 



---

<a name="71"></a> [⇪⇪⇪](#0)

### 49. Оператор HAVING.

Оператор HAVING (имеющие, при условии) обычно применяется совместно с оператором группировки GROUP BY и задает фильтр записей в группах. Правила его формирования такие же, что и для оператора WHERE. 

Предположим, что из таблицы клиенты требуется выбрать данные о регионах и суммах заказов, сгруппированные по регионам и такие, в которых сумма заказа превышает 500. Иначе говоря, требуется сгруппировать данные с ограничением записей, входящих в группы. Запрос, выполняющий это задание, имеет вид: 

    SELECT Регион, Сумма_заказа FROM Клиенты 
    GROUP BY Регион, Сумма_заказа 
    HAVING Сумма заказа > 500; 

Если в SQL-выражении оператора GROUP BY нет, то оператор HAVING применяется ко всем записям, возвращаемым оператором WHERE. Если же отсутствует И WHERE, то HAVING действует на все записи таблицы. 

---

<a name="72"></a> [⇪⇪⇪](#0)

### 50. Оператор ORDER ВУ.

Оператор ORDER BY (сортировать по) применяется для сортировки записей. Если он используется в запросе, то в самом конце запроса. Этот оператор сортирует строки всей таблицы или отдельных ее групп (в случае применения оператора  GROUP BY). Если в выражении запроса оператора GROUP BY нет, то оператор ORDER BY рассматривает все записи таблицы как одну группу. 

Вслед за ключевым словом ORDER BY указывается столбец, по значениям которого следует произвести сортировку. После имени столбца можно указать ключевое слово, задающее порядок (режим) сортировки: 

* ASC — по возрастанию (ascending). Это значение принято по умолчанию, поэтому если необходима сортировка, например, в алфавитном порядке, то специально указывать порядок не требуется; 
* DESC — по убыванию (descending). 

Если в выражении ORDER BY указаны несколько столбцов сортировки, то сначала записи упорядочиваются по значениям первого столбца, затем для каждого значения первого столбца записи упорядочиваются по значениям второго столбца и т. д. Столбцы в списке разделяются, как обычно, запятыми. Таким образом, создается иерархическая система сортировки записей результатной таблицы. 

В следующем примере данные исходной таблицы Клиенты сортируются по регионам и по именам клиентов. При этом сортировка по именам клиентов производится по убыванию, т. е. в порядке, противоположном алфавитному. 

    SELECT * FROM Клиенты 
    ORDER BY Регион, ИМЯ DESC; 


---

<a name="73"></a> [⇪⇪⇪](#0)

### 51. Логические операторы.

Логические выражения в операторах WHERE и HAVING могут быть сложными, т. е. состоять из двух и более простых выражений, соединенных между собой логическими операторами (союзами) AND и/или OR. Оператор AND выполняет роль логического союза И, а оператор OR — союза ИЛИ. Так, если х и у — два логических выражения, то составное выражение х AND у принимает значение true (ИСТИНА) только тогда, когда х и у одновременно истинны; в противном случае выражение х AND у принимает значение false (ЛОЖЬ). Выражение х oR у истинно, если хотя бы одно из выражений, х или у, истинно; если х и у одновременно ложны, то составное выражение х OR у ложно. 

Логический оператор NOT применяется к одному выражению (возможно и к сложному), расположенному справа от него. Этот оператор меняет значение выражения на противоположное. Так, если выражение х имеет значение true, то выражение NOT х имеет значение false, и, наоборот, если х ложно, то NOT х истинно. 
Предположим, из таблицы клиенты требуется выбрать записи о клиентах из Москвы и Северо-Запада. Соответствующий запрос имеет вид: 

    SELECT Регион, Имя, Сумма_заказа FROM Клиенты 
    WHERE Регион ='Москва' OR Регионе='Северо-Запад'; 

Обратите внимание, что здесь используется логический оператор OR (ИЛИ), а не AND (И), поскольку нам нужны клиенты, проживающие или в Москве, или на Северо-Западе. Если бы вместо оператора OR мы применили AND, то получили бы пустую таблицу, т. к. в исходной таблице нет ни одной записи, в которой один - и тот же столбец имел бы различные значения. 
Будьте внимательны при формулировке запроса на естественном: языке и при его переводе на SQL. 

Следующее SQL-выражение эквивалентно рассмотренному ранее. Оно основано на применении оператора IN: 

    SELECT Регион, Имя, Сумма заказа FROM Клиенты 
    WHERE Регион IN ('Москва', 'Северо-Запад'); 

Если требуется получить данные о всех клиентах, которые не проживают ни в Москве, ни на Северо-Западе, то можно использовать такое SQL-выражение: 

    SELECT Регион, Имя, Сумма_заказа FROM Клиенты 
    WHERE NOT (Регионе'Москва' OR Регионе'Северо-Запад' ); 

Эго выражение эквивалентно следующим двум: 

    SELECT Регион, Имя, Сумма_заказа FROM Клиенты 
    WHERE Регион <> 'Москва' AND Регион <> 'Северо-Запад'; 
        
    SELECT Регион, Имя, Сумма_заказа FROM Клиенты 
    WHERE Регион NOT IN ('Москва', 'Северо-Запад'); 


---

<a name="74"></a> [⇪⇪⇪](#0)

### 52. Итоговые функции.

Довольно часто требуется узнать, сколько записей соответствует тому или иному запросу, какова сумма значений некоторого числового столбца, его максимальное, минимальное и среднее значения. Для этого служат так называемые итоговые (статистиче- ские, агрегатные) функции. Итоговые функции обрабатывают наборы записей, заданные, например, выражением WHERE. Если их включить в список столбцов, следующий за оператором SELECT, то результатная таблица будет содержать не только столбцы таблицы базы данных, но и значения, вычисленные с помощью этих функций. Далее приведен список итоговых функций. 

* COUNT(параметр) — возвращает количество записей, указанных в параметре. Если требуется получить количество всех записей, то в качестве параметра следует указать символ звездочки (\*), Если в качестве параметра указать имя столбца, то функция вернет количество записей, в которых этот столбец имеет значения, отличные от NULL. Чтобы узнать, сколько различных значений содержит столбец, перед его именем следует указать ключевое слово DISTINCT. 
Например: 

        SELЕСТ COUNT (*) FROM Клиенты; . 
        SELECT COUNT (Сумма_заказа) FROM Клиенты; 
        SELECT COUNT(DISTINCT Сумма_заказа) FROM Клиенты; 
        
    Попытка выполнить следующий запрос приведет к сообщению об ошибке: 

        SELECT Регион, COUNT(\*) FROM Клиенты; 

* SUM (параметр) — возвращает сумму значений указанного в параметре столбца. Параметр может представлять собой и выражение, содержащее имя столбца. Например: 
SELECT SUM(Сумма_заказа) FROM Клиенты; 
Данное SQL-выражение возвращает таблицу, состоящую из одного столбца и одной записи и содержащую сумму всех определенных значений столбца Сумма_заказа из таблицы Клиенты.\
Допустим, что в исходной таблице значения столбца Сумма_заказа выражены в рублях, а нам требуется вычислить общую сумму в долларах. Если текущий обменный курс равен, например, 32,8, то получить требуемый результат можно с помощью выражения: 

        SELECT SUM(Сумма_заказа/32.8) FROM Клиенты; 

* AVG(параметр) — возвращает среднее арифметическое всех значений указанного в параметре столбца. Параметр может представлять собой выражение, содержащее имя столбца. Например: 
  
        SELECT AVG (Сумма_заказа) FROM Клиенты; 
        SELECT AVG(Сумма_заказа/32.8) FROM Клиенты 
        WHERE Регион <> 'Северо_Запад'; 

* Мах(параметр) — возвращает максимальное значение в столбце, указанном в параметре. Параметр может также представлять собой выражение, содержащее имя столбца. Например: 

        SELECT МАХ(Сумма_заказа) FROM Клиенты; 
        SELECT МАХ(Сумма_заказа*32.8) FROM Клиенты WHERE Регион <> 'Северо_Запад'; 

* MIN(параметр) — возвращает минимальное значение в столбце, указанном в параметре. Параметр может представлять собой выражение, содержащее имя столбца. Например: 

        SELECT MIN(Сумма_заказа) FROM Клиенты; 
        SELECT MIN(Сумма_заказа*32,8) FROM Клиенты WHERE Регион <> 'Северо_Запад'; 

На практике нередко требуется получить итоговую таблицу, содержащую суммарные, усредненные, максимальные и минимальные значения числовых столбцов. Для этого следует испольэовать группировку (GROUP BY) и итоговые функции.  

    SELECT Регион, SUM(Сумма_заказа) FROM Клиенты GROUP BУ Регион; 

Результатная таблица для данного запроса содержит имена регионов и итоговые (общие) суммы заказов всех клиентов из соответствующих регионов. 
Теперь рассмотрим запрос на получение всех итоговых данных по регионам: 

    SELECT Регион, SUM(Сумма_заказа), AVG(Сумма_заказа), МАХ(Сумма_заказа), MIN(Сумма_заказа) 
    FROM Клиенты 
    GROUP BY Регион; 

При использовании итоговых функций в списке столбцов в операторе SELECT заголовки соответствующих им столбцов в таблице результата имеют вид Ехрг1001, Ехрг1002 и т. д. (или что- нибудь аналогичное, в зависимости от реализации SQL). Однако заголовки для значений итоговых функций и других столбцов вы можете задавать по своему усмотрению. Для этого достаточно после столбца в операторе SELECT указать выражение вида: 

    AS заголовок столбца 

Ключевое слово AS (как) означает, что в результатной таблице соответствующий столбец должен иметь заголовок, указанный после AS. Назначаемый заголовок еще называют псевдонимом. В следующем примере задаются псевдонимы для всех вычисляемых столбцов: 

    SELECT Регион, 
    SUM(Сумма_заказа) АS [общая сумма заказа], 
    AVG(Сумма_заказа) AS [Средняя сумма заказа], 
    МАХ(Сумма_заказа) АS Максимум, 
    MIN(Сумма_заказа) AS Минимум FROM Клиенты 
    GROUP BY Регион; 

Псевдонимы, состоящие из нескольких слов, разделенных пробелами, заключаются в квадратные скобки. 

Итоговые функции можно использовать в выражениях SELECT и HAVING, но их нельзя применять в выражении WHERE. Оператор HAVING аналогичен оператору WHERE но в отличие от WHERE он отбирает записи в группах. 

Допустим, требуется определить, в каких регионах более одного клиента. С этой целью можно воспользоваться таким запросом: 

    SELECT Регион, Count(*) FROM Клиенты 
    GROUF BY Регион HAVING COUNT(*) >. 1;

---

<a name="75"></a> [⇪⇪⇪](#0)

### 53. Функции обработки значений.

При работе с данными часто приходится их обрабатывать (преобразовывать к нужному виду): выделить в строке некоторую подстроку, удалить ведущие и заключительные пробелы, округлить число, вычислить квадратный корень, определить текущее время и т. п. В SQL имеются следующие три типа функций: 

* строковые функции;
* числовые функции; 
* функции даты-времени.

<a name="76"></a> [⇪⇪⇪](#0)

#### 53.1. Строковые функции.

Строковые функции принимают в качестве параметра строку и возвращают после ее обработки строку или NULL. 

**SUBSTRING(строка FROM начало [FOR длина])** — возвращает подстроку, получающуюся из строки, которая указана в качестве параметра строка. Подстрока начинается с символа, порядковый номер которого указан в параметре начало, и имеет длину, указанную в параметре длина. Нумерация символов строки ведется слева направо, начиная с 1. Квадратные скобки здесь указывают лишь на то, что заключенное в них выражение не является обязательным. Если выражение FOR длина не используется, то возвращается подстрока от начало и до конца исходной строки. Значения параметров начало и длина должны выбираться так, чтобы искомая подстрока действительно находилась внутри исходной строки. В противном случае функция SUBSTRING вернет NULL.

Например: 

    SUBSTRING ('Дорогая Маша!' FROM 9 FOR 4) — возвращяет  ‘Маша!’; 
    SUBSTR1NG ('дорогая маша!' FROM 9) — возвращает 'маша!' 
    SUBSTRING ('дорогая маша!' FROM 15) — возвращает NULL. 
Использовать эту функцию в SQL-выражении можно, например так:

    SELECT * FROM клиенты 
    WHERE SUBSTRING(Peгион FROM 1 FOR 5) = 'Север'; 

**UPPER(строка)** — переводит все символы указанной в параметре строки в верхний регистр.\
**LOWER(строка)** — переводит все символы указанной в параметре строки в нижний регистр.\
**TRIM(LEADING |TRAILING|BOTH| [' символ '] FROM строка)** — удаляет начальные (LEADING), заключительные (TRAILING) или те и другие (BOTH) символы из строки. По умолчанию удаляемым символом является пробел (‘ ‘), поэтому его можно не указывать.

Чаще всего эта функция используется именно для удаления пробелов. 

Например: 

    TRIM(LEADING ‘ ‘ FROM ‘           город Санкт-Петербург        ‘) — Возвращает 'город Санкт-Петербург        ‘
    TRIM(TRALING ' ' FROM '   город санкт-петербург    ') — возвращает ‘   город Санкт-Петербург'; 
    TRIM(BOTH ' ' FROM '    город санкт-петербург    ') — возвращает 'город Санкт-Петербург'; 
    TRIM(BOTH ‘г’ ‘город санкт-петербург' ) — возвращает ‘ород Санкт-Петербург'; 

Среди этих функций наиболее часто используемые SUBSTRING() и TRIM(). 

<a name="77"></a> [⇪⇪⇪](#0)

#### 53.2. Числовые функции.

Числовые функции в качестве параметра могут принимать данные не только числового типа, но возвращают всегда число или NULL (неопределенное значение). 

**POSITION( целевая строка IN строка)** — ищет вхождение целевой строки в указанную строку. В случае успешного поиска возвращает номер положения ее первого символа, иначе — 0. Если целевая строка имеет нулевую длину (например, пустая строка ' '), то функция возвращает 1. Если хотя бы один из параметров имеет значение NULL, то возвращается NULL. Нумерация символов строки ведется слева направо, начиная с 1. 

Например: 
    
    POSITION('е' IN 'Привет всем') — возвращает 5;
    POSITION('всем' IN 'Привет всем') — возвращает 8; 
    POSITION(‘’ IN ‘привет всем') — возвращает 1; 
    POSITION('привет!' IN 'привет всем') — возвращает 0.

В таблице клиенты столбец Адрес содержит, кроме названия города, почтовый индекс, название улицы и другие данные. Возможно, вам потребуется выбрать записи о клиентах, проживающих в определенном городе. Так, если требуется выбрать записи, относящиеся к клиентам, проживающим в Санкт-Петербурге, то можно воспользоваться следующим выражением SQL-запроса: 

    SELECT * FROM Клиенты 
    WHERE POSITION(‘Санкт-Петербург' IN **Адрес**) > 0; 

Заметим, что этот простой запрос на выборку данных можно сформулировать иначе: 

    SELECT * FROM Клиенты 
    WHERE Адрес LIKE '%Петербург% '; 

**EXTRACT(параметр)** — извлекает элемент из значения типа дата-время или из интервала. Например: 

    EXTRACT (MONTH FROM DATE ‘2005-10-25’ ) — возвращает 10. 

**CHARACTER_LENGTH ( строка )** — возвращает количество символов в строке. 

Например: 

    CHARACTER_LENGTH ( 'Привет всем' ) — возвращает 11. 

**OCTET_LENGTH( строка )** — возвращает количество октетов (байтов) в строке. Каждый символ латиницы или кириллицы представляется одним байтом, а символ китайского алфавита — двумя байтами.\
**CARDINALITY(параметр)** — принимает в качестве параметра коллекцию элементов и возвращает количество элементов в коллекции (кардинальное число). Коллекция может быть, например, массивом или мультимножеством, содержащим элементы различных типов.\
**ABS(число)** — возвращает абсолютное значение числа. 

Например: 

    ABS (-123 ) — возвращает 123; 
    ABS (2 — 5) — возвращает 3. 

**MOD(число1, число2)** — возвращает остаток от целочисленного деления первого числа на второе. 

Например: 

    MOD(5, 3) — возвращает 2;
    MOD(2, 3) — возвращает О. 

**LN(число)** — возвращает натуральный логарифм числа.\
**EXP(число)** — возвращает ечисло (основание натурального логарифма в степени число).\ 
**POWER(число1, число2)** — возвращает число1число2 (число1 в степени число2).\
**SQRT( исло)** — возвращает квадратный корень из числа.\
**FLOOR(число)** — возвращает наибольшее целое число, не превышающее заданное параметром (округление в меньшую сторону). 

Например: 

    FLOOR(5.123) — возвращает 5.0. 

**CEIL(число) или CEILING(число)** — возвращает наименьшее целое число, которое не меньше заданного параметром (округление в большую сторону). 

Например: 

    CEIL(5.123) — возвращает 6.0.

**WIDTH_BUCKET( число1, число2, числоЗ, число4)** — возвращает целое число в диапазоне между 0 и число4 + 1. Параметры число2 и числоЗ задают числовой отрезок, разделенный на равновеликие интервалы, количество которых задается параметром число4. Функция определяет номер интервала, в который попадает значение число1. Если число1 находится за пределами заданного диапазона, то функция возвращает 0 или число4 + 1. 

Например: 

    WIDTH_BUCKET(3.14, 0, 9, 5) — возвращает 2. 

<a name="78"></a> [⇪⇪⇪](#0)

#### 53.3. Функции даты-времени.

В языке SQL имеются три функции, которые возвращают текущие дату и время. 

* CURRENT_DATE — возвращает текущую дату (тип DATE). Например, 2005-06-18.
* CURRENT_TIME(число) — возвращает текущее время (тип TIME). Целочисленный параметр указывает точность представления секунд. Например, при значении 2 секунды будут представлены с точностью до сотых (две цифры в дробной части): 
12:39 45.27. 
* CURRENT_TIMESTAMP(число) — возвращает дату и время (тип TIMESTAMP). Например,
 
        2005-06-18   12:39:45.27. 
    
Целочисленный параметр указывает точность представления секунд. 
  
Обратите внимание, что дата и время, возвращаемые этими функциями, имеют не символьный тип. Если требуется представить их в виде символьных строк, то для этого следует использовать функцию преобразования типа CAST(). 

Функции даты-времени обычно применяются в запросах на вставку, обновление и удаление данных. Например, при записи сведений о продажах в специально предусмотренный для этого столбец вносятся текущие дата и время. После подведения итогов за месяц или квартал, данные о продажах за отчетный период можно удалить. 

---

<a name="79"></a> [⇪⇪⇪](#0)

### 54. Вычисляемые выражения.

Вычисляемые выражения строятся из констант (числовых, строковых, логических), функций, имен полей и данных других типов путем соединения их арифметическими, строковыми, логическими и другими операторами. В свою очередь, выражения могут быть объединены посредством операторов в более сложные (составные) выражения. Для управления порядком вычисления выражений используются круглые скобки. 
Логические операторы AND, OR и NOT были рассмотрены ранее

Арифметические операторы приведены далее: 

* \+ — сложение; 
* \- — вычитание; 
* \* — умножение; 
* / — деление. 

Строковый оператор только один — оператор конкатенации или склейки строк (||) В некоторых реализациях (например, в Microsoft Access) вместо (||) используется символ (+). Оператор конкатенации приписывает вторую строку к концу первой. 
Например, выражение: 

    'Саша’ || ‘любит’||’ Машу' 

вернет в качестве результата строку 'Сашалюбит машу'. 

При составлении выражений необходимо следить, чтобы операнды операторов имели допустимые типы. Например, выражение: 

    123 + 'Саша' 

недопустимо, поскольку арифметический оператор сложения применяется к строковому операнду. 

Вычисляемые выражения могут находиться после оператора SELECT, а также в выражениях условий операторов WHERE и HAVING. Рассмотрим несколько примеров. 

Пусть таблица Продажи содержит столбцы Тип_товара, Количество и цена, а нам требуется знать выручку для каждого типа товара. Для этого достаточно в список столбцов после оператора SELECT включить выражение количество*цена.

    SELECT Тип_товара, Количество, Цена, Количество*Цена AS Итого 
    FROM Продажи; 

Здесь используется ключевое слово AS (как) для задания псевдонима столбца с вычисляемыми данными. 

Если требуется узнать общую выручку от продажи всех товаров; то достаточно применить следующий запрос: 

    SELECT SUM(количество*цена) FROM Продажи,

Следующий запрос содержит вычисляемые выражения и в списке столбцов, и в условии оператора WHERE. 

Он выбирает из таблицы продажи те товары, выручка от продажи которых больше 1000: 

    SELECT Тип_товара, Количество*цена AS Итого 
    FROM Продажи 
    WHERE количество*цена > 1000; 

Предположим, что требуется получить таблицу, в которой два столбца: 

1. товар, содержащий тип товара и цену; 
2. итого, содержащий выручку. 

Поскольку предполагается, что в исходной таблице продажи столбец тип товара является символьным (тип CHAR), а столбец цена — числовой, то при объединении (склейке) данных из этих столбцов необходимо выполнить приведение числового типа к символьному с помощью функции CAST().

Запрос, выполняющий это задание, выглядит так: 

    SELECT Тип_товара || ‘(Цена:  ‘ || CAST(Цена AS СНАR(5)) ||  ‘)’
    AS Товар, Количество*цена AS Итого 
    FROM продажи; 

Примечание 
В Microsoft Access аналогичный запрос будет иметь следующий вид: 

    SELECT Тип_товара & “ (Цена: “ & CSTR(Цена) & “) “ AS Товар, 
    Количество*Цена AS Итого 
    FROM Продажи; 

---

<a name="80"></a> [⇪⇪⇪](#0)

### 55. Условные выражения с оператором САSЕ.

В обычных языках программирования имеются операторы условного перехода, которые позволяют управлять вычислительным процессом в зависимости от того, выполняется или нет некоторое условие. 

В языке SQL таким оператором является CASE (случай, обстоятельство, экземпляр). В SQL этот оператор возвращает значение и, следовательно, может использоваться в выражениях. 

Он имеет две основные формы, которые мы рассмотрим. 


<a name="81"></a> [⇪⇪⇪](#0)

#### 55.1. Оператор САSЕ со значениями.

Оператор CASE со. значениями имеет следующий синтаксис: 

    CASE проверяемое_значение 
        WHEN значение1 THEN результат1 
        WHEN значение2 THEN результат2 
        ....
        WHEN значениеN THEN результатN 
        ELSE результат X
    END
 
В случае, когда проверяемое значение равно значение1, оператор CASE возвращает значение результат1, указанное после ключевого слова THEN (то). 
В противном случае проверяемое значение сравнивается с значение2, и если они равны, то возвращается значение результат2. В противном случае проверяемое значение сравнивается со следующим значением, указанным после ключевого слова WHEN (когда) и т.д. Если проверяемое значение не равно ни одному из таких значений, то возвращается значение результатХ, указанное после ключевого слова ELSE (иначе). 

Ключевое слово ELSE не является обязательным. Если оно отсутствует и ни одно из значений, подлежащих сравнению, не равно проверяемому значению, то оператор CASE возвращает NULL. 

Допустим, на основе таблицы клиенты  требуется получить таблицу, в которой названия регионов заменены их кодовыми номерами. Если в исходной таблице различных регионов не слишком много, то для решения данной задачи удобно воспользоваться запросом с оператором CASE: 

    SELECT Имя, Адрес 
    CASE Регион 
        WHEN 'Москва' THEN ' 77 ' 
        WHEN 'Тверская область' THEN '69'
        .... 
        ELSE Регион 
    END
    AS Код региона
    FROM Клиенты; 


<a name="82"></a> [⇪⇪⇪](#0)

#### 55.2. Оператор САSЕ с условиями поиска.

Вторая форма оператора CASE предполагает его использование при поиске в таблице тех записей, которые удовлетворяют определенному условию: 

    CASE 
        WHEN условие1 THEN результат1 
        WHEN условие2 THEN результат2 
        ....
        WHEN условиеN THEN результатN 
        ELSE результатХ 
    END 

Оператор CASE проверяет, истинно ли условие1 для первой записи в наборе, определенном оператором WHERE, или во всей таблице, если WHERE отсутствует. Если да, то CASE возвращает значение результат1. В противном случае для данной записи проверяется условие2. Если оно истинно, то возвращается значение результат2 и т. д. Если ни одно из условий не выполняется, то возвращается значение результатX, указанное после ключевого слова ELSE. 

Ключевое слово ELSE не является обязательным. Если оно отсутствует и ни одно из условий не выполняется, оператор CASE возвращает NULL. 

После того как оператор, содержащий CASE, выполнится для первой записи, происходит переход к следующей записи. Так продолжается до тех пор, пока не будет обработан весь набор записей. 

Предположим, в таблице книги (название, цена) столбец цена имеет значение NULL, если соответствующей книги нет в наличии. 

Следующий запрос возвращает таблицу, в которой вместо NULL отображается текст "Нет в наличии". 

    SELECT Название 
    CASE
        WHEN цена IS NULL THEN ‘Нет в продаже’
        ELSE CAST (AS CHAR(8))
    END
    AS цена
    FROM Книги;

Все значения одного и того же столбца должны иметь одинаковые типы. Поэтому в данном запросе используется функция преобразования типов CAST() для приведения числовых значений столбца цена к символьному типу. 

Обратите внимание, что вместо первой формы оператора CASE всегда можно использовать вторую: 

    CASE 
        WHEN проверяемое_значение=значение1 THEN резульнат1
        WHEN  проверяемое_значение=значение2 THEN резульнат2
        ....    
        WHEN   проверяемое_значение=значениеN THEN резульнатN
        ELSE резульнатX
    END

<a name="83"></a> [⇪⇪⇪](#0)

#### 55.3. Функции NULLIF и COALESCE.

В ряде случаев, особенно в запросах на обновление данных (оператор UPDATE), удобно использовать вместо громоздкого оператора CASE более компактные функции NULLIF() (NULL, если) и COALESCE() (объединять). 

Функция **NULLIF(значение1, значение2)** возвращает NULL, если значение первого параметра соответствует значению второго параметра, в случае несоответствия возвращается значение первого параметра без изменений. 

То есть если равенство значение1 = значение2 выполняется, то функция возвращает NULL, иначе — значение значение1. 

Данная функция эквивалентна оператору CASE в следующих двух формах:
 
    CASE значение1 
        WHEN значение2 THEN NULL 
        ELSE значение1 
    END

    CASE 
        WHEN значение1 = значение2 THEN NULL 
        ELSE значение1
    END

Функция **COALESCE( значение1, значение2, ..., значениеN)** принимает список значений, которые могут быть как определенными, так и неопределенными (NULL). Функция возвращает первое определенное значение из списка или NULL, если все значения не определены. 

Данная функция эквивалентна следующему оператору CASE 

    CASE 
        WHEN значение1 IS NOT NULL THEN значение1 
        WHEN значение2 IS NOT NULL THEN значение2 
        ....
        WHEN значениеN IS NOT NULL THEN значениеN 
        ELSE NULL
    END

Предположим, что в таблице Книги (Название, Цена) столбец Цена имеет значение NULL, если соответствующей книги нет в наличии. Следующий запрос возвращает таблицу, в которой вместо NULL, отображается текст "нет в наличии": 

    SELECT Название, COALESCE(САST(Цена AS CHAR(8) ), 
    'Нет в наличии') AS Цена 
    FROM книги; 

---
